{
    "algorithme": {
        "prefix": ["algorithme"],
        "body": ["algorithme ${1:nom}", "début", "\t$0", "fin"],
        "description": "Structure de base d'un algorithme : entête, début et fin."
    },
    "fonction (définition)": {
        "prefix": ["fonction", "fn"],
        "body": [
            "fonction ${1:nom}(${2:paramètres_formels}) : ${3|entier,chaîne,réel,booléen,caractère|}",
            "début",
            "\t$0",
            "fin"
        ],
        "description": "Définit une fonction : sous-programme qui calcule et renvoie une valeur."
    },
    "procédure (définition)": {
        "prefix": ["procédure", "proc"],
        "body": [
            "procédure ${1:nom}(${2:paramètres_formels})",
            "début",
            "\t$0",
            "fin"
        ],
        "description": "Définit une procédure : sous-programme qui exécute des actions sans renvoyer de valeur."
    },
    "tdo: 1 ligne": {
        "prefix": "tdo-1",
        "body": [
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ ${1:x}                                  │ ${2|entier       ,chaîne       ,réel         ,booléen      ,caractère    ,fonction     ,procédure    ,fichier texte|}            │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "tableau de déclaration des objets"
    },
    "tdo: 3 lignes": {
        "prefix": "tdo-3",
        "body": [
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ ${1:x}                                  │ ${2|entier       ,chaîne       ,réel         ,booléen      ,caractère    ,fonction     ,procédure    ,fichier texte|}            │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ ${3:y}                                  │ ${4|entier       ,chaîne       ,réel         ,booléen      ,caractère    ,fonction     ,procédure    ,fichier texte|}            │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ ${5:z}                                  │ ${6|entier       ,chaîne       ,réel         ,booléen      ,caractère    ,fonction     ,procédure    ,fichier texte|}            │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "tableau de déclaration des objets (3 lignes)"
    },
    "nouveau type: tableau": {
        "prefix": ["tdnt-1"],
        "body": [
            "┌───────────────────────────────────────────────────────────────┐",
            "│                        Nouveaux Types                         │",
            "├───────────────────────────────────────────────────────────────┤",
            "│ ${1:tab} = tableau de ${2:20} ${3|entier   ,chaîne   ,réel     ,booléen  ,caractère|}                                 │",
            "└───────────────────────────────────────────────────────────────┘",
            ""
        ],
        "description": "déclaration des nouveaux types"
    },
    "nouveaux types: 2en1": {
        "prefix": ["tdnt-2"],
        "body": [
            "┌───────────────────────────────────────────────────────────────┐",
            "│                        Nouveaux Types                         │",
            "├───────────────────────────────────────────────────────────────┤",
            "│ ${1:eleve} = enregistrement                                        │",
            "│     ${2:nom} : ${3|chaîne   ,entier   ,réel     ,booléen  ,caractère|}                                           │",
            "│     ${4:age} : ${5|entier   ,chaîne   ,réel     ,booléen  ,caractère|}                                           │",
            "│ fin                                                           │",
            "├───────────────────────────────────────────────────────────────┤",
            "│ ${6:tab} = tableau de ${7:20} ${8|entier   ,chaîne   ,réel     ,booléen  ,caractère|}                                 │",
            "└───────────────────────────────────────────────────────────────┘",
            ""
        ],
        "description": "nouveaux types: enregistrement + tableau"
    },
    "boucle pour": {
        "prefix": "pour",
        "body": ["pour ${1:i} de ${2:0} à ${3:N-1} faire", "\t$0", "fin_pour"],
        "description": [
            "Boucle pour (for-loop).",
            "Structure itérative utilisée lorsque le nombre de répétitions est connu à l'avance.",
            "La variable de contrôle parcourt une plage définie (DEBUT → FIN).",
            "Syntaxe de base : pour i de DEBUT à FIN faire ... fin_pour",
            "",
            "Optionnel : un pas personnalisé peut être spécifié (valeur par défaut = 1).",
            "  - Syntaxe complète : pour i de DEBUT à FIN (pas = x) faire ...",
            "  - Règle de validité : si pas > 0, alors DEBUT ≤ FIN ; si pas < 0, alors DEBUT ≥ FIN.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemples :",
            "  pour i de 1 à 10 (pas = 2) faire",
            "    écrire(i)",
            "  fin_pour",
            "  → Affiche : 1 3 5 7 9",
            "",
            "  pour i de 10 à 1 (pas = -2) faire",
            "    écrire(i)",
            "  fin_pour",
            "  → Affiche : 10 8 6 4 2",
            "",
            "  pour i de 5 à 2 (pas = 1) faire",
            "    écrire(i)",
            "  fin_pour",
            "  → Aucune itération (pas > 0 mais DEBUT > FIN)."
        ]
    },
    "si...alors": {
        "prefix": "si-alors",
        "body": ["si ${1:condition} alors", "\t$0", "fin_si"],
        "description": [
            "Structure conditionnelle simple (if).",
            "Permet d'exécuter un bloc d'instructions UNIQUEMENT si la condition spécifiée est VRAIE.",
            "Syntaxe : si CONDITION alors ... fin_si",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 (Condition VRAIE) :",
            "  age <-- 25",
            "  si age ≥ 18 alors",
            "    écrire('Majeur')",
            "  fin_si",
            "  → Affiche : Majeur",
            "",
            "Exemple 2 (Condition FAUSSE) :",
            "  age <-- 15",
            "  si age ≥ 18 alors",
            "    écrire('Majeur')",
            "  fin_si",
            "  → Aucune sortie "
        ]
    },
    "si...alors...sinon": {
        "prefix": "si-sinon",
        "body": ["si ${1:condition} alors", "\t$0", "sinon", "\t", "fin_si"],
        "description": [
            "Structure conditionnelle complète (if-else).",
            "Exécute le bloc 'alors' si la condition est vraie, sinon le bloc 'sinon'.",
            "Syntaxe : si CONDITION alors ... sinon ... fin_si",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 (Condition VRAIE) :",
            "  temp <-- 5",
            "  si temp > 0 alors",
            "    écrire('Chaud')",
            "  sinon",
            "    écrire('Froid')",
            "  fin_si",
            "  → Affiche : Chaud",
            "",
            "Exemple 2 (Condition FAUSSE) :",
            "  temp <-- -5",
            "  si temp > 0 alors",
            "    écrire('Chaud')",
            "  sinon",
            "    écrire('Froid')",
            "  fin_si",
            "  → Affiche : Froid"
        ]
    },
    "structure selon": {
        "prefix": "selon",
        "body": [
            "selon ${1:sélecteur}",
            "\t${2:2, 4, 6} : ${3:traitement_1}",
            "\t${4:7..10} : ${5:traitement_2}",
            "\tsinon ${6:traitement_3}",
            "fin_selon",
            "$0"
        ],
        "description": [
            "Structure à choix multiple (switch).",
            "Permet d'exécuter un bloc d'instructions parmi plusieurs, selon la valeur du sélecteur.",
            "Le sélecteur: une variable qui doit être de type ordinal : entier ou caractère.",
            "Les cas peuvent être :",
            "  - une valeur unique (ex. : 1),",
            "  - une liste de valeurs (ex. : 2, 4, 6),",
            "  - un intervalle (ex. : 7..10).",
            "Le bloc 'sinon' est optionnel et s'exécute si aucune correspondance n'est trouvée.",
            "~~~~~~~~~~~~~~",
            "Exemple 1 (Caractère) :",
            "  selon c",
            "    'A'..'Z' : écrire('Lettre majuscule')",
            "    'a'..'z' : écrire('Lettre minuscule')",
            "    '0'..'9' : écrire('Chiffre')",
            "    '!', '?', '.' : écrire('Ponctuation')",
            "    sinon écrire('Autre caractère')",
            "  fin_selon",
            "",
            "Exemple 2 (Entier) :",
            "  selon jour",
            "    1..5 : écrire('Jour ouvré')",
            "    6..7 : écrire('Week-end')",
            "    sinon écrire('Jour invalide')",
            "  fin_selon"
        ]
    },
    "boucle tant-que": {
        "prefix": "tant-que",
        "body": ["tant que ${1:condition} faire", "\t$0", "fin_tant_que"],
        "description": [
            "Structure itérative à condition d'entrée (while-loop).",
            "Répète un bloc d'instructions tant que la condition spécifiée est VRAIE.",
            "La condition est testée AVANT chaque itération. La boucle peut ne jamais s'exécuter.",
            "Syntaxe : tant que CONDITION faire ... fin_tant_que",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 :",
            "  i <-- 1",
            "  tant que i ≤ 3 faire",
            "    écrire(i)",
            "    i <-- i + 1",
            "  fin_tant_que",
            "  → Affiche : 1 2 3",
            "",
            "Exemple 2 :",
            "  i <-- 5",
            "  tant que i ≤ 3 faire",
            "    écrire(i)",
            "    i <-- i + 1",
            "  fin_tant_que",
            "  → Aucune sortie : la condition est FAUSSE dès le départ."
        ]
    },
    "boucle répéter": {
        "prefix": ["répéter", "repeter"],
        "body": ["répéter", "\t$0", "jusqu'à ${1:condition}"],
        "description": [
            "Structure itérative à condition d'arrêt (repeat-until loop).",
            "Répète un bloc d'instructions jusqu'à ce que la condition spécifiée devienne VRAIE.",
            "La condition est testée APRÈS la première itération. La boucle s'exécute au moins une fois.",
            "Syntaxe : répéter ... jusqu'à CONDITION",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1:",
            "  i <-- 1",
            "  répéter",
            "    écrire(i)",
            "    i <-- i + 1",
            "  jusqu'à i > 3",
            "  → Affiche : 1 2 3",
            "",
            "Exemple 2 (Condition déjà VRAIE au départ) :",
            "  i <-- 5",
            "  répéter",
            "    écrire(i)",
            "    i <-- i + 1",
            "  jusqu'à i > 3",
            "  → Affiche : 5 (S'exécute une seule fois)"
        ]
    },
    "de": {
        "prefix": "de",
        "body": ["de $0"]
    },
    "début": {
        "prefix": ["début", "debut"],
        "body": ["début $0"]
    },
    "faire": {
        "prefix": "faire",
        "body": ["faire $0"]
    },
    "fin": {
        "prefix": "fin",
        "body": ["fin $0"]
    },
    "fin_pour": {
        "prefix": "fin_pour",
        "body": ["fin_pour $0"]
    },
    "fin_si": {
        "prefix": "fin_si",
        "body": ["fin_si $0"]
    },
    "fin_selon": {
        "prefix": "fin_selon",
        "body": ["fin_selon $0"]
    },
    "fin_tant_que": {
        "prefix": "fin_tant_que",
        "body": ["fin_tant_que $0"]
    },
    "jusqu'à": {
        "prefix": "jusqu'à",
        "body": ["jusqu'à $0"]
    },
    "pas": {
        "prefix": "pas",
        "body": ["pas $0"]
    },
    "retourner": {
        "prefix": "retourner",
        "body": ["retourner $0"],
        "description": [
            "instruction : retourner expression",
            "Termine l'exécution d'une fonction et renvoie la valeur de l'expression.",
            "",
            "Règles :",
            "  - La valeur retournée doit être de type simple :",
            "    entier, réel, booléen, caractère ou chaîne.",
            "  - Une seule instruction retourner peut être exécutée.",
            "    Si plusieurs sont présentes, elles doivent se trouver dans des chemins",
            "    mutuellement exclusifs (ex. : si...sinon).",
            "",
            "Note : réservée aux fonctions, pas aux procédures.",
            "",
            "Exemple 1 : utilisation correcte",
            "  fonction exemple_fn(x: entier) : entier",
            "  début",
            "    si x > 0 alors",
            "      retourner 10",
            "    sinon",
            "      retourner 20",
            "    fin_si",
            "  fin",
            "  → ✅ Retourne 10 si x > 0, sinon 20",
            "",
            "Exemple 2 : utilisation incorrecte",
            "  fonction exemple_fn(x: entier) : entier",
            "  début",
            "    si x > 0 alors",
            "      retourner 10",
            "    fin_si",
            "    retourner 20",
            "  fin",
            "  → ❌ Erreur : deux instructions retourner peuvent être exécutées",
            "",
            "Exemple 3 : alternative recommandée (retour unique)",
            "  fonction exemple_fn(x: entier) : entier",
            "  début",
            "    résultat <-- 20",
            "    si x > 0 alors",
            "      résultat <-- 10",
            "    fin_si",
            "    retourner résultat",
            "  fin",
            "  → ✅ Un seul point de retour, plus facile à déboguer"
        ]
    },
    "selon": {
        "prefix": "selon",
        "body": ["selon $0"]
    },
    "sinon": {
        "prefix": "sinon",
        "body": ["sinon $0"]
    },
    "fonction aléa()": {
        "prefix": ["aléa", "alea"],
        "body": ["aléa(${1:vi}, ${2:vf}) $0"],
        "description": [
            "fonction aléa(vi: entier, vf: entier): entier",
            "",
            "Génère un entier aléatoire compris entre vi et vf (bornes incluses).",
            "Contrainte: vi ≤ vf.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 : Lancer de dé",
            "  x <-- aléa(1, 6)",
            "  → x ∈ {1, 2, 3, 4, 5, 6}",
            "",
            "Exemple 2 : Lettre majuscule aléatoire",
            "  code_ascii <-- aléa(65, 90)",
            "  lettre <-- chr(code_ascii)",
            "  → contient un caractère entre \"A\" et \"Z\""
        ]
    },
    "fonction arrondi()": {
        "prefix": "arrondi",
        "body": ["arrondi(${1:x}) $0"],
        "description": [
            "fonction arrondi(x: réel): entier",
            "",
            "Retourne l'entier le plus proche du nombre réel donné.",
            "Règle : Si la décimale est .5, on arrondit toujours à l'entier supérieur.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 (Décimale < .5) :",
            "  x <-- arrondi(12.3)",
            "  → x vaut 12",
            "",
            "Exemple 2 (Décimale > .5) :",
            "  x <-- arrondi(12.7)",
            "  → x vaut 13",
            "",
            "Exemple 3 (Règle du .5) :",
            "  x <-- arrondi(12.5)",
            "  → x vaut 13 (Arrondi au supérieur)"
        ]
    },
    "fonction chr()": {
        "prefix": "chr",
        "body": ["chr(${1:code_ascii}) $0"],
        "description": [
            "fonction chr(code_ascii: entier): caractère",
            "",
            "Retourne le caractère correspondant au code ASCII (ou Unicode) donné.",
            "Contrainte : Le code doit être un entier positif (entre 0 et 255 pour ASCII étendu).",
            "Fonction inverse de ord().",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 : Lettre majuscule",
            "  c <-- chr(65)",
            "  → c vaut \"A\"",
            "",
            "Exemple 2 : Lettre minuscule",
            "  c <-- chr(97)",
            "  → c vaut \"A\"",
            "",
            "Exemple 3 : Chiffre",
            "  c <-- chr(48)",
            "  → c vaut \"0\""
        ]
    },
    "fonction convch()": {
        "prefix": "convch",
        "body": ["convch(${1:x}) $0"],
        "description": [
            "fonction convch(x: réel | entier): chaîne",
            "",
            "Convertit un nombre (entier ou réel) en une chaîne de caractères.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 (entier) :",
            "  ch <-- convch(42)",
            "  → ch vaut \"42\"",
            "",
            "Exemple 2 (réel) :",
            "  ch <-- convch(3.14)",
            "  → ch vaut \"3.14\"",
            "",
            "Exemple 3 (affichage formaté) :",
            "  age <-- 17",
            "  message <-- \"J'ai \" + convch(age) + \" ans.\"",
            "  → message vaut \"J'ai 17 ans.\""
        ]
    },
    "fonction effacer()": {
        "prefix": "effacer",
        "body": ["effacer(${1:ch}, ${2:d}, ${3:f}) $0"],
        "description": [
            "fonction effacer(ch: chaîne, d: entier, f: entier): chaîne",
            "",
            "Retourne une copie de la chaîne ch après suppression des caractères",
            "situés entre les positions d et f (d incluse, f exclue).",
            "Contrainte : 0 ≤ d < f ≤ long(ch)",
            "Note : L'indexation commence à 0 (premier caractère = indice 0).",
            "",
            "~~~~~~~~~~~~~~",
            "// ch = \"B o n j o u r\"",
            "//       0 1 2 3 4 5 6 ",
            "",
            "Exemple 1 :",
            "  ch_res <-- effacer(ch, 1, 4)",
            "  → ch_res vaut \"Bour\", ch reste inchangée (=\"Bonjour\")",
            "",
            "Exemple 2 (suppression à la fin):",
            "  ch_res  <-- effacer(ch, 3, long(ch))",
            "  → ch_res vaut \"Bon\""
        ]
    },
    "fonction ent()": {
        "prefix": "ent",
        "body": ["ent(${1:x}) $0"],
        "description": [
            "fonction ent(x: réel): entier",
            "",
            "Retourne la partie entière du nombre réel x.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 (Positif) :",
            "  x <-- ent(12.75)",
            "  → x vaut 12",
            "",
            "Exemple 2 (Négatif) :",
            "  x <-- ent(-12.75)",
            "  → x vaut -12 (Troncature vers zéro)"
        ]
    },
    "fonction estnum()": {
        "prefix": "estnum",
        "body": ["estnum(${1:ch}) $0"],
        "description": [
            "fonction estnum(ch: chaîne): booléen",
            "",
            "Retourne vrai si la chaîne ch peut être convertie en nombre (entier ou réel),",
            "faux sinon.Utile avant d'utiliser la fonction valeur(ch) pour éviter les erreurs.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 (vrai) :",
            "  estnum(\"123\")    → vrai (entier)",
            "  estnum(\"-3.14\")  → vrai (réel négatif)",
            "  estnum(\"1.5e-3\") → vrai (notation scientifique)",
            "",
            "Exemple 2 (faux) :",
            "  estnum(\"47abc\")  → faux (contient des caractères non valides)",
            "  estnum(\"12.3.5\") → faux (format numérique invalide)",
            "  estnum(\"2 + 3\")  → faux (n'est pas une simple valeur numérique)"
        ]
    },
    "procédure fermer()": {
        "prefix": "fermer",
        "body": ["fermer(${1:f}) $0"],
        "description": [
            "procédure fermer(@f: fichier)",
            "",
            "Ferme le fichier associé à la variable f et libère les ressources système.",
            "Après fermeture, la variable f n'est plus liée au fichier physique.",
            "Il est recommandé de toujours fermer un fichier après utilisation.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple :",
            "  ouvrir(\"data.txt\", f, \"w\")",
            "  // ... écriture dans le fichier ...",
            "  fermer(f)"
        ]
    },
    "fonction fin_fichier()": {
        "prefix": "fin_fichier",
        "body": ["fin_fichier(${1:f}) $0"],
        "description": [
            "fonction fin_fichier(@f: fichier): booléen",
            "",
            "Retourne vrai si le pointeur de lecture est à la fin du fichier f, faux sinon.",
            "Contrainte : f doit être ouvert en mode lecture ('r' ou 'rb').",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple : Affichage du contenu d'un fichier texte",
            "  ouvrir(\"noms.txt\", f, \"r\")",
            "  si non fin_fichier(f) alors",
            "    lire(f, ch)",
            "    écrire(ch)",
            "  fin_si",
            "  fermer(f)"
        ]
    },

    "procédure lire()": {
        "prefix": "lire",
        "body": ["lire(${1:var}) $0"],
        "description": [
            "procédure lire(@var: entier | réel | caractère | chaîne)",
            "procédure lire(@f: fichier texte, @var: chaîne)",
            "procédure lire(@f: fichier de <type>, @var: <type>)",
            "",
            "Permet de récupérer des données depuis le clavier ou un fichier.",
            "La syntaxe dépend de la source :",
            "",
            "1. Saisie Clavier :",
            "  - Syntaxe : lire(var)",
            "  - var doit être de type entier, réel, caractère ou chaîne",
            "  - Lit une seule valeur depuis le clavier",
            "  - Exemple : lire(age) → demande à l'utilisateur de saisir l'âge.",
            "",
            "2. Lecture fichier texte (mode \"r\") :",
            "  - Syntaxe : lire(f, ch)",
            "  - Lit tout le contenu restant (depuis le pointeur courant)",
            "  - Exemple : lire(f, contenu)",
            "",
            "3. Lecture fichier binaire (mode \"rb\") :",
            "  - Syntaxe : lire(f, e)",
            "  - Lit un seul élément, et avance le pointeur",
            "  - Exemple : si f: fichier de entier → lire(f, e) lit un entier",
            "",
            "~~~~~~~~~~~~~~",
            "Exemples d'usage :",
            "// 1. Clavier",
            "  lire(nom)",
            "",
            "// 2. Fichier texte",
            "  ouvrir(\"texte.txt\", f, \"r\")",
            "  lire(f, ch)",
            "  fermer(f)",
            "",
            "// 3. Fichier binaire",
            "  ouvrir(\"nombres.dat\", f, \"rb\")",
            "  lire(f, x)",
            "  fermer(f)"
        ]
    },
    "procédure lire_ligne()": {
        "prefix": "lire_ligne",
        "body": ["lire_ligne(${1:f}, ${2:ch}) $0"],
        "description": [
            "procédure lire_ligne(@f: fichier texte, @ch: chaîne)",
            "",
            "Lit une ligne complète depuis le fichier texte f et la stocke dans ch.",
            "Après la lecture, le pointeur du fichier avance au début de la ligne suivante",
            "ou à la fin du fichier si aucune ligne ne reste",
            "Le caractère de fin de ligne (retour à la ligne) n'est pas inclus dans ch",
            "Contrainte : f doit être ouvert en mode lecture (\"r\").",
            "⚠️ Ne s'applique qu'aux fichiers texte.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple : Lecture ligne par ligne d'un fichier",
            "  ouvrir(\"data.txt\", f, \"r\")",
            "  tant que non fin_fichier(f) faire",
            "    lire_ligne(f, ligne)",
            "    écrire_nl(\"Ligne lue : \", ligne)",
            "  fin_tant_que",
            "  fermer(f)"
        ]
    },
    "fonction long()": {
        "prefix": "long",
        "body": ["long(${1:ch}) $0"],
        "description": [
            "fonction long(ch: chaîne): entier",
            "",
            "Retourne le nombre de caractères de ch.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 :",
            "  n <-- long(\"Algo\")",
            "  → n vaut 4",
            "",
            "Exemple 2 :",
            "  n <-- long(\"\")",
            "  → n vaut 0",
            "",
            "Exemple 3 :",
            "  n <-- long(\"123 ABC!\")",
            "  → n vaut 8 (les espaces et symboles sont comptés)"
        ]
    },
    "fonction majus()": {
        "prefix": "majus",
        "body": ["majus(${1:cc}) $0"],
        "description": [
            "fonction majus(cc: chaîne | caractère): chaîne | caractère",
            "",
            "Convertit tous les caractères alphabétiques de cc en majuscules.",
            "Les caractères non-alphabétiques restent inchangés.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 : chaîne",
            "  ch <-- majus(\"1. Algo /!\\\")",
            "  → ch vaut \"1. ALGO /!\\\"",
            "",
            "Exemple 2 : caractère",
            "  c <-- majus(\"a\")",
            "  → c vaut \"A\""
        ]
    },
    "fonction ord()": {
        "prefix": "ord",
        "body": ["ord(${1:c}) $0"],
        "description": [
            "fonction ord(c: caractère): entier",
            "",
            "Retourne le code ASCII (ou Unicode) du caractère c.",
            "Fonction inverse de chr().",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 : Lettre majuscule",
            "  n <-- ord(\"A\")",
            "  → n = 65",
            "",
            "Exemple 2 : Lettre minuscule",
            "  n <-- ord(\"a\")",
            "  → n = 97",
            "",
            "Exemple 3 : Chiffre",
            "  n <-- ord(\"0\")",
            "  → n = 48",
            "",
            "Exemple 4 : Caractère spécial",
            "  n <-- ord(\"#\")",
            "  → n = 35"
        ]
    },
    "procédure ouvrir()": {
        "prefix": "ouvrir",
        "body": ["ouvrir(${1:chemin}, ${2:f}, \"${3:r}\") $0"],
        "description": [
            "procédure ouvrir(chemin: chaîne, @f: fichier, mode: chaîne)",
            "",
            "Ouvre un fichier à l'emplacement chemin et l'associe à la variable f.",
            "Le mode d'ouverture détermine le type d'accès :",
            "",
            "  • \"r\"  : lecture (fichier texte)",
            "    \"rb\" : lecture (fichier binaire)",
            "",
            "  • \"w\"  : écriture (crée ou écrase le fichier texte)",
            "    \"wb\" : écriture (crée ou écrase le fichier binaire)",
            "",
            "  • \"a\"  : ajout à la fin du fichier texte",
            "    \"ab\" : ajout à la fin du fichier binaire",
            "",
            "Le suffixe \"b\" indique que le fichier est traité en mode binaire.",
            "",
            "Note : Le chemin peut être relatif ou absolu:",
            "  - relatif (recommandé pour la portabilité) : ",
            "    Le chemin est défini par rapport à l'emplacement du programme.",
            "    exemple → \"data.txt\" ou \"docs\\data.txt\"",
            "  - absolu : Le chemin est complet depuis la racine du système.",
            "    exemple → \"C:\\Users\\MonNom\\Desktop\\log.txt\"",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 (lecture texte) :",
            "  ouvrir(\"notes.txt\", f, \"r\")",
            "",
            "Exemple 2 (écriture binaire) :",
            "  ouvrir(\"archive.dat\", f, \"wb\")"
        ]
    },
    "fonction pos()": {
        "prefix": "pos",
        "body": ["pos(${1:sous_ch}, ${2:ch}) $0"],
        "description": [
            "fonction pos(sous_ch: chaîne, ch: chaîne): entier",
            "",
            "Retourne la position de la première occurrence de sous_ch dans ch.",
            "Si sous_ch n'est pas trouvée, retourne -1.",
            "Note : L'indexation commence à 0 (premier caractère = indice 0).",
            "",
            "~~~~~~~~~~~~~~",
            "// ch = \"B o n j o u r\"",
            "//       0 1 2 3 4 5 6 ",
            "",
            "Exemple 1 :",
            "  p <-- pos(\"o\", ch)",
            "  → p vaut 1",
            "",
            "Exemple 2 :",
            "  p <-- pos(\"jour\", ch)",
            "  → p vaut 3",
            "",
            "Exemple 3 (non trouvé) :",
            "  p <-- pos(\"xyz\", ch)",
            "  → p vaut -1"
        ]
    },
    "fonction racine_carrée()": {
        "prefix": "racine_carrée",
        "body": ["racine_carrée(${1:x}) $0"],
        "description": [
            "fonction racine_carrée(x: réel): réel",
            "",
            "Retourne la racine carrée du nombre x.",
            "Contrainte : x doit être positif ou nul (x ≥ 0).",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 :",
            "  r <-- racine_carrée(25)",
            "  → r vaut 5.0",
            "",
            "Exemple 2 :",
            "  r <-- racine_carrée(2)",
            "  → r vaut environ 1.414"
        ]
    },
    "fonction sous_chaîne()": {
        "prefix": "sous_chaîne",
        "body": ["sous_chaîne(${1:ch}, ${2:d}, ${3:f}) $0"],
        "description": [
            "fonction sous_chaîne(ch: chaîne, d: entier, f: entier): chaîne",
            "",
            "Retourne une nouvelle chaîne contenant les caractères de ch",
            "situés entre les positions d et f (d incluse, f exclue).",
            "Contrainte : 0 ≤ d < f ≤ long(ch)",
            "Note : L'indexation commence à 0 (premier caractère = indice 0).",
            "",
            "~~~~~~~~~~~~~~",
            "// ch = \"B o n j o u r\"",
            "//       0 1 2 3 4 5 6",
            "",
            "Exemple 1 (extraction du début) :",
            "  ch_res <-- sous_chaîne(ch, 0, 3)",
            "  → ch_res vaut \"Bon\", ch reste inchangée (=\"Bonjour\")",
            "",
            "Exemple 2 :",
            "  ch_res <-- sous_chaîne(ch, 3, long(ch))",
            "  → ch_res vaut \"jour\"",
            "",
            "Exemple 3 (extraction d'un seul caractère) :",
            "  ch_res <-- sous_chaîne(ch, 2, 3)",
            "  → ch_res vaut \"n\""
        ]
    },
    "fonction valeur()": {
        "prefix": "valeur",
        "body": ["valeur(${1:ch}) $0"],
        "description": [
            "fonction valeur(ch: chaîne): entier | réel",
            "",
            "Convertit la chaîne ch en valeur numérique (entier ou réel).",
            "Contrainte : la chaîne doit représenter un nombre valide.",
            "Recommandation : utiliser estnum(ch) pour vérifier avant conversion.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 : entier",
            "  n <-- valeur('42')",
            "  → n vaut 42",
            "",
            "Exemple 2 : réel",
            "  x <-- valeur('3.14')",
            "  → x vaut 3.14",
            "",
            "Exemple 3 : notation scientifique",
            "  x <-- valeur('1.5e-2')",
            "  → x vaut 0.015",
            "",
            "Exemple 4 : vérification avec estnum()",
            "  si estnum(ch) alors",
            "    n <-- valeur(ch)",
            "  sinon",
            "    écrire(\"Erreur : ch n'est pas un nombre valide\")",
            "  fin_si"
        ]
    },
    "procédure écrire()": {
        "prefix": ["écrire", "ecrire"],
        "body": ["écrire(${1:expression}) $0"],
        "description": [
            "procédure écrire(exp_1 [, exp_2, ...])",
            "procédure écrire(@f: fichier texte, exp: chaîne)",
            "procédure écrire(@f: fichier de <type>, exp: <type>)",
            "",
            "Permet d'afficher des valeurs à l'écran ou de les écrire dans un fichier.",
            "La syntaxe dépend du nombre et du type des paramètres :",
            "",
            "1. Affichage à l'écran (sortie standard) :",
            "   - Syntaxe : écrire(exp1 [, exp2, ...])",
            "   - Chaque expression doit être de type simple :",
            "     entier, réel, caractère, chaîne ou booléen.",
            "   - Les valeurs sont affichées sans saut de ligne (concaténées).",
            "   - Exemple : écrire(\"Résultat = \", x) → affiche « Résultat = 42 ».",
            "",
            "2. Écriture dans un fichier texte (mode \"w\" ou \"a\") :",
            "   - Syntaxe : écrire(f, ch)",
            "   - Écrit la chaîne ch à la position courante du fichier texte f.",
            "   - Aucun retour à la ligne automatique.",
            "   - Exemple : écrire(f, \"Bonjour\")",
            "",
            "3. Écriture dans un fichier binaire (mode \"wb\" ou \"ab\") :",
            "  - Syntaxe : écrire(f, e)",
            "  - Écrit un seul élément e dans le fichier binaire f.",
            "  - Contrainte : Le type de e doit correspondre au type des éléments de f.",
            "  - Exemple : écrire(f, 42)  // f : fichier de entier",
            "",
            "~~~~~~~~~~~~~~",
            "Exemples d'usage :",
            "// 1. Écran",
            "  écrire(\"Nom : \", nom, \", Âge : \", age)",
            "  → affiche « Nom : Ali, Âge : 16 »",
            "",
            "// 2. Fichier texte",
            "  ouvrir(\"log.txt\", f, \"a\")",
            "  écrire(f, \"[INFO] Traitement terminé\")",
            "  fermer(f)",
            "",
            "// 3. Fichier binaire",
            "  ouvrir(\"scores.dat\", f, \"wb\")",
            "  écrire(f, score)  // score est un entier",
            "  fermer(f)"
        ]
    },
    "procédure écrire_nl()": {
        "prefix": ["écrire_nl", "ecrire_nl"],
        "body": ["écrire_nl(${1:expression}) $0"],
        "description": [
            "procédure écrire_nl(exp_1 [, exp_2, ...])",
            "procédure écrire_nl(@f: fichier texte, exp: chaîne)",
            "",
            "Identique à la procédure 'écrire', mais ajoute un retour à la ligne :",
            "la prochaine écriture se fera sur une nouvelle ligne",
            "",
            "⚠️ Ne s'applique pas aux fichiers binaires.",
            "",
            "1. Affichage à l'écran avec saut de ligne :",
            "   - Syntaxe : écrire_nl(exp1 [, exp2, ...])",
            "   - Affiche les valeurs puis passe à la ligne suivante.",
            "   - Exemple : écrire_nl(\"Résultat = \", x)",
            "               → affiche « Résultat = 42 » puis saute une ligne.",
            "",
            "2. Écriture dans un fichier texte avec saut de ligne :",
            "   - Syntaxe : écrire_nl(f, ch)",
            "   - Écrit la chaîne ch suivie d'un retour à la ligne dans le fichier f.",
            "   - Exemple : écrire_nl(f, \"Ligne de texte\")",
            "     → écrit \"Ligne de texte\" puis passe à la ligne suivante.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemples d'usage :",
            "// 1. Écran avec sauts de ligne",
            "  écrire_nl(\"=== Début du programme ===\")",
            "  écrire_nl(\"Résultat :\", calcul)",
            "  écrire_nl(\"=== Fin ===\")",
            "  → affiche 3 lignes distinctes",
            "",
            "// 2. Fichier texte avec lignes séparées",
            "  ouvrir(\"rapport.txt\", f, \"w\")",
            "  écrire_nl(f, \"Titre du rapport\")",
            "  écrire_nl(f, \"===============\")",
            "  écrire_nl(f, \"Contenu...\")",
            "  fermer(f)",
            "  → crée un fichier avec 3 lignes distinctes"
        ]
    },
    "type booléen": {
        "prefix": ["booléen"],
        "body": ["booléen$0"]
    },
    "type caractère": {
        "prefix": ["caractère"],
        "body": ["caractère$0"]
    },
    "type chaîne": {
        "prefix": ["chaîne", "chaine"],
        "body": ["chaîne$0"]
    },
    "type enregistrement": {
        "prefix": "enregistrement",
        "body": ["enregistrement$0"]
    },
    "type entier": {
        "prefix": "entier",
        "body": ["entier$0"]
    },
    "type fichier texte": {
        "prefix": ["text", "fichier-texte"],
        "body": ["fichier texte$0"]
    },
    "type fichier typé": {
        "prefix": "fichier-typé",
        "body": ["fichier de ${1:entier}$0"]
    },
    "type réel": {
        "prefix": ["réel", "reel"],
        "body": ["réel$0"]
    },
    "type tableau": {
        "prefix": "tableau",
        "body": ["tableau de ${1:20} ${2:entier}$0"]
    },
    "type fonction": {
        "prefix": "fonction",
        "body": ["fonction $0"]
    },
    "type procédure": {
        "prefix": ["procédure", "proc"],
        "body": ["procédure $0"]
    },
    "opérateur ≥": {
        "prefix": [">="],
        "body": ["≥ $0"],
        "description": [
            "opérateur ≥ (supérieur ou égal)",
            "",
            "Syntaxe : expression1 ≥ expression2",
            "Retourne vrai si expression1 est supérieure ou égale à expression2,",
            "faux sinon.",
            "",
            "S'applique uniquement aux types simples : ",
            "  - entier, réel, booléen, caractère et chaîne.",
            "Contrainte : Les deux expressions doivent être de types compatibles",
            "pour la comparaison.",
            "",
            "Types compatibles :",
            "  - entier, réel : comparaison numérique",
            "  - caractère, chaîne : comparaison ASCII/lexicographique",
            "  - booléen : faux < vrai",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 : nombres",
            "  5 ≥ 3     → vrai",
            "  4 ≥ 4.0   → vrai",
            "  2 ≥ 5     → faux",
            "",
            "Exemple 2 : caractères",
            "  \"C\" ≥ \"A\" → vrai  (67 ≥ 65 en ASCII)",
            "  \"a\" ≥ \"A\" → vrai  (97 ≥ 65)",
            "",
            "Exemple 3 : chaînes",
            "  \"Ali\" ≥ \"Ahmed\" → vrai (comparaison lexicographique)",
            "  \"Ali\" ≥ \"Alia\"  → faux",
            "",
            "Exemple 4 : booléens",
            "  vrai ≥ faux → vrai"
        ]
    },
    "opérateur ≤": {
        "prefix": ["<="],
        "body": ["≤ $0"],
        "description": [
            "opérateur ≤ (inférieur ou égal)",
            "",
            "Syntaxe : expression1 ≤ expression2",
            "Retourne vrai si expression1 est inférieure ou égale à expression2,",
            "faux sinon.",
            "",
            "S'applique uniquement aux types simples : ",
            "  - entier, réel, booléen, caractère et chaîne.",
            "Contrainte : Les deux expressions doivent être de types compatibles",
            "pour la comparaison.",
            "",
            "Types compatibles :",
            "  - entier, réel : comparaison numérique",
            "  - caractère, chaîne : comparaison ASCII/lexicographique",
            "  - booléen : faux < vrai",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 : nombres",
            "  3 ≤ 5     → vrai",
            "  4.0 ≤ 4   → vrai",
            "  5 ≤ 2     → faux",
            "",
            "Exemple 2 : caractères",
            "  \"A\" ≤ \"C\" → vrai  (65 ≤ 67 en ASCII)",
            "  \"A\" ≤ \"a\" → vrai  (65 ≤ 97)",
            "",
            "Exemple 3 : chaînes",
            "  \"Ahmed\" ≤ \"Ali\" → vrai (comparaison lexicographique)",
            "  \"Alia\" ≤ \"Ali\"  → faux",
            "",
            "Exemple 4 : booléens",
            "  faux ≤ vrai → vrai"
        ]
    },
    "opérateur ∈": {
        "prefix": ["in", "dans", "appartient"],
        "body": "∈ $0",
        "description": [
            "opérateur ∈ (appartient à / est dans)",
            "",
            "Syntaxe : expression ∈ [intervalle] ou expression ∈ {ensemble}",
            "",
            "Retourne vrai si la valeur appartient à l'ensemble ou à l'intervalle spécifié,",
            "faux sinon.",
            "",
            "S'applique uniquement aux types ordinaux :",
            "  - entier, caractère, booléen.",
            "⚠️ Ne s'applique pas aux réels ni aux chaînes.",
            "",
            "Formes autorisées :",
            "  - Intervalle : [début .. fin]   (bornes incluses)",
            "  - Ensemble : {v1, v2, ..., vn}",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 : entiers",
            "  x ∈ [10 .. 20]      → vrai si x est entre 10 et 20 (inclus)",
            "  x ∈ {2, 4, 6, 8}    → vrai si x est pair et ≤ 8",
            "",
            "Exemple 2 : caractères",
            "  c ∈ [\"A\" .. \"Z\"]    → vrai si c est une lettre majuscule",
            "  c ∈ {\"A\", \"E\", \"I\", \"O\", \"U\", \"Y\"} → vrai si c est une voyelle",
            "",
            "Exemple 3 : booléens",
            "  b ∈ {vrai, faux}    → toujours vrai",
            "  b ∈ {faux}          → vrai seulement si b est faux"
        ]
    },
    "opérateur =": {
        "prefix": ["="],
        "body": "= $0",
        "description": [
            "opérateur = (égal)",
            "",
            "Syntaxe : expression1 = expression2",
            "Retourne vrai si expression1 est égale à expression2,",
            "faux sinon.",
            "",
            "S'applique uniquement aux types simples : ",
            "  - entier, réel, booléen, caractère et chaîne.",
            "Contrainte : Les deux expressions doivent être de types compatibles",
            "pour la comparaison.",
            "",
            "Types compatibles :",
            "  - entier, réel : comparaison numérique",
            "  - caractère, chaîne : comparaison ASCII/lexicographique",
            "  - booléen : comparaison des valeurs booléennes",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 : nombres",
            "  5 = 3     → faux",
            "  4 = 4.0   → vrai",
            "  2 = 2     → vrai",
            "",
            "Exemple 2 : caractères",
            "  'A' = 'a' → faux  (65 ≠ 97 en ASCII)",
            "  'B' = 'B' → vrai",
            "",
            "Exemple 3 : chaînes",
            "  \"Ali\" = \"Ahmed\" → faux",
            "  \"test\" = \"test\" → vrai",
            "",
            "Exemple 4 : booléens",
            "  vrai = faux → faux",
            "  vrai = vrai → vrai",
            "",
            "Note : Ne pas confondre avec l'opérateur d'affectation '<--'"
        ]
    },
    "opérateur ≠": {
        "prefix": ["!=", "<>"],
        "body": ["≠ $0"],
        "description": [
            "opérateur ≠ (différent)",
            "",
            "Syntaxe : expression1 ≠ expression2",
            "Retourne vrai si expression1 et expression2 ont des valeurs différentes,",
            "faux si elles sont égales.",
            "",
            "S'applique à tous les types simples :",
            "  - entier, réel, booléen, caractère et chaîne.",
            "Contrainte : Les deux expressions doivent être de types compatibles",
            "pour la comparaison.",
            "",
            "Types compatibles :",
            "  - entier, réel : comparaison numérique",
            "  - caractère, chaîne : comparaison lexicographique (basée sur ASCII)",
            "  - booléen : faux ≠ vrai",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 : nombres",
            "  5 ≠ 3     → vrai",
            "  4 ≠ 4.0   → faux",
            "  2 ≠ 2     → faux",
            "",
            "Exemple 2 : caractères",
            "  \"A\" ≠ \"a\" → vrai  (65 ≠ 97 en ASCII)",
            "  \"#\" ≠ \"#\" → faux",
            "",
            "Exemple 3 : chaînes",
            "  \"Ali\" ≠ \"Ahmed\" → vrai",
            "  \"Test\" ≠ \"Test\" → faux",
            "",
            "Exemple 4 : booléens",
            "  vrai ≠ faux → vrai",
            "  faux ≠ faux → faux"
        ]
    },
    "affectation (<--)": {
        "prefix": ["<--"],
        "body": ["<-- $0"],
        "description": [
            "Opérateur d'affectation :",
            "stocke la valeur d'une expression dans une case mémoire.",
            "",
            "Syntaxe :",
            "  case_mémoire <-- expression",
            "",
            "La case mémoire doit être de type simple :",
            "  - entier, réel, booléen, caractère ou chaîne",
            "",
            "La case mémoire peut être :",
            "  - une variable simple (ex. : age),",
            "  - un élément de tableau (ex. : T[0], T[i]),",
            "  - un champ d'enregistrement (ex. : personne.nom).",
            "",
            "Contrainte :",
            "  l'expression doit être compatible avec le type de la case mémoire.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemples :",
            "  x <-- 42",
            "  T[i] <-- x + 1",
            "  pers.nom <-- \"Ali\""
        ]
    },
    "opérateur et": {
        "prefix": "et",
        "body": ["et $0"]
    },
    "opérateur ou": {
        "prefix": "ou",
        "body": ["ou $0"]
    },
    "opérateur non": {
        "prefix": "non",
        "body": ["non $0"]
    },
    "opérateur div": {
        "prefix": "div",
        "body": ["div $0"]
    },
    "opérateur mod": {
        "prefix": "mod",
        "body": ["mod $0"]
    },
    "faux": {
        "prefix": "faux",
        "body": ["faux $0"]
    },
    "vrai": {
        "prefix": "vrai",
        "body": ["vrai $0"]
    },
    "saisie contrôlée d'un nombre": {
        "prefix": ["x-saisir-N"],
        "body": [
            "procédure ${1:saisir}(@${2:N}: entier)",
            "début",
            "\trépéter",
            "\t\técrire(\"${3:Saisir N:} \") ",
            "\t\tlire(${2:N})",
            "\tjusqu'à  ${6:${4:5} ≤ ${2:N} ≤ ${5:20}}",
            "fin",
            ""
        ],
        "description": "(proc) saisie contrôlée d'un nombre"
    },
    "remplissage d'un tableau": {
        "prefix": ["x-remplir-tableau"],
        "body": [
            "procédure ${1:remplir}(@${2:T}: ${3:tab}, ${4:N}:entier)",
            "début",
            "\tpour i de 0 à ${4:N}-1 faire",
            "\t\trépéter",
            "\t\t\técrire(\"${5:Nom} n°\", i, \": \") ",
            "\t\t\tlire(${2:T}[i]) ",
            "\t\tjusqu'à  ${6:long(${2:T}[i]) ≠ 0}",
            "\tfin_pour",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i                                  │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "(proc) remplissage contrôlé d'un tableau à une dimension"
    },
    "affichage d'un tableau": {
        "prefix": ["x-afficher-tableau"],
        "body": [
            "procédure ${1:afficher}(${2:T}: ${3:tab}, ${4:N}:entier)",
            "début",
            "\tpour i de 0 à ${4:N}-1 faire",
            "\t\técrire(\"${5:Nom} n°\", i, \": \", ${2:T}[i])",
            "\tfin_pour",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i                                  │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "(proc) affichage d'un tableau"
    },
    "remplissage d'une matrice carrée": {
        "prefix": ["x-remplir-matrice-carrée"],
        "body": [
            "procédure ${1:remplir}(@${2:T}: ${3:mat}, ${4:N}:entier)",
            "début",
            "\tpour i de 0 à ${4:N}-1 faire",
            "\t\tpour i de 0 à ${4:N}-1 faire",
            "\t\t\trépéter",
            "\t\t\t\técrire(\"${2:T}[\", i, \",\", j, \"]: \") ",
            "\t\t\t\tlire(${2:T}[i, j]) ",
            "\t\t\tjusqu'à  ${5:${2:T}[i, j] ≥ 0}",
            "\t\tfin_pour",
            "\tfin_pour",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i, j                               │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "(proc) remplissage contrôlé d'une matrice carrée"
    },
    "remplissage d'une matrice": {
        "prefix": ["x-remplir-matrice"],
        "body": [
            "procédure ${1:remplir}(@${2:T}: ${3:mat}, ${4:nb_lignes}, ${5:nb_colonnes} :entier)",
            "début",
            "\tpour i de 0 à ${4:nb_lignes}-1 faire",
            "\t\tpour j de 0 à ${5:nb_colonnes}-1 faire",
            "\t\t\trépéter",
            "\t\t\t\técrire(\"${2:T}[\", i, \",\", j, \"]: \") ",
            "\t\t\t\tlire(${2:T}[i, j]) ",
            "\t\t\tjusqu'à  ${6:${2:T}[i, j] ≥ 0}",
            "\t\tfin_pour",
            "\tfin_pour",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i, j                               │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "(proc) remplissage contrôlé d'une matrice"
    },
    "tri à bulles": {
        "prefix": ["x-tri-à-bulles"],
        "body": [
            "/*",
            "Pricipe du tri à bulles :",
            "1) Parcours et Comparaison : Parcourir le tableau en comparant les éléments adjacents (voisins) deux à deux.",
            "\t- Si deux éléments adjacents ne sont pas ordonnés, les permuter (échanger de place).",
            "2) Répétition : Répéter l'étape 1 jusqu'à ce qu'un parcours complet soit effectué sans aucune permutation.",
            "*/",
            "procédure ${1:tri_à_bulles}(@${2:T}: ${3:tab}, ${4:N}:entier)",
            "début",
            "\trépéter",
            "\t\taucune_permutation <-- vrai",
            "\t\tpour i de 0 à ${4:N}-2 faire",
            "\t\t\tsi ${2:T}[i] ${5|>,<|} ${2:T}[i+1] alors",
            "\t\t\t\t${6:aux} <-- ${2:T}[i]",
            "\t\t\t\t${2:T}[i] <-- ${2:T}[i+1]",
            "\t\t\t\t${2:T}[i+1] <-- ${6:aux}",
            "\t\t\t\taucune_permutation <-- faux",
            "\t\t\tfin_si",
            "\t\tfin_pour",
            "\tjusqu'à  aucune_permutation",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i                                  │ entier                   │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ aucune_permutation                 │ booléen                  │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ ${6:aux}                                │ ${7|entier   ,chaîne   ,réel     ,booléen  ,caractère|}                │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "(proc) tri à bulles"
    },
    "tri par sélection (v.1)": {
        "prefix": ["x-tri-sélection-1"],
        "body": [
            "/*",
            "Principe du Tri par Sélection :",
            "1) Rechercher le plus petit élément dans la partie non triée du tableau (initialement à partir de la première position).",
            "   - Le placer, par permutation, à la position en cours (initialement la première position).",
            "2) Répéter l'étape 1 jusqu'à la fin du tableau.",
            "*/",
            "procédure ${1:tri_par_sélection}(@${2:T}: ${3:tab}, ${4:N}:entier)",
            "début",
            "\tpour i de 0 à ${4:N}-2 faire",
            "\t\t// recherche de la position du ${5|min,max|}imum",
            "\t\tpos_${5|min,max|} <-- i",
            "\t\tpour j de i+1 à ${4:N}-1 faire",
            "\t\t\tsi ${2:T}[j] ${6|<,>|} ${2:T}[pos_${5|min,max|}] alors",
            "\t\t\t\tpos_${5|min,max|} <-- j",
            "\t\t\tfin_si ",
            "\t\tfin_pour",
            "\t\t",
            "\t\t// permutation de la case actuelle (numéro i) avec ",
            "\t\t// la case qui contient le ${5|min,max|}imum (numéro pos_${5|min,max|})",
            "\t\tsi i ≠ pos_${5|min,max|} alors",
            "\t\t\t ${7:aux} <-- ${2:T}[i]",
            "\t\t\t${2:T}[i] <-- ${2:T}[pos_${5|min,max|}]",
            "\t\t\t${2:T}[pos_${5|min,max|}] <--  ${7:aux}",
            "\t\tfin_si",
            "\tfin_pour",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i, j, pos_${5|min,max|}                      │ entier                   │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ ${7:aux}                                │ ${8|entier   ,chaîne   ,réel     ,booléen  ,caractère|}                │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "(proc) tri par sélection (v.1)"
    },
    "tri par sélection (v.2)": {
        "prefix": ["x-tri-sélection-2"],
        "body": [
            "/*",
            "Principe du tri par sélection :",
            "1) Rechercher, à partir de la [première position], le plus petit élément du tableau,",
            "   - Le placer, par permutation, à la [première position],",
            "2) Répéter l'étape 1 à partir de la [deuxième position], et ainsi de suite jusqu'à la fin du tableau.",
            "*/",
            "procédure ${1:tri_par_sélection}(@${2:T}: ${3:tab}, ${4:N}:entier)",
            "début",
            "\tpour i de 0 à ${4:N}-2 faire",
            "\t\tpos_${5|min,max|} <-- chercher_pos_${5|min,max|}(${2:T}, i, ${4:N}-1)",
            "\t\tpermuter(${2:T}[i], ${2:T}[pos_${5|min,max|}])",
            "\tfin_pour\t\t",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i, pos_${5|min,max|}                         │ entier                   │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ chercher_pos_${5|min,max|}                   │ fonction                 │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ permuter                           │ procédure                │",
            "└────────────────────────────────────┴──────────────────────────┘",
            "",
            "fonction chercher_pos_${5|min,max|}(${2:T}: ${3:tab}, b_ini, b_fin: entier) : entier",
            "début",
            "\tpos_${5|min,max|} <-- b_ini",
            "\tpour i de b_ini + 1 à b_fin faire",
            "\t\tsi ${2:T}[i] ${6|<,>|} ${2:T}[pos_${5|min,max|}] alors",
            "\t\t\tpos_${5|min,max|} <-- i",
            "\t\tfin_si",
            "\tfin_pour",
            "\tretourner pos_${5|min,max|}",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i, pos_${5|min,max|}                         │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            "",
            "",
            "procédure permuter(@x, @y: ${8|entier   ,chaîne   ,réel     ,booléen  ,caractère|})",
            "début",
            "\taux <-- x",
            "\tx <-- y",
            "\ty <-- aux",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ aux                                │ ${8|entier   ,chaîne   ,réel     ,booléen  ,caractère|}                │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "(proc) tri par sélection (v.2)"
    },
    "tri par insertion": {
        "prefix": ["x-tri-insertion"],
        "body": [
            "/*",
            "Principe du Tri par Insertion :",
            "1) Prendre le premier élément de la partie non triée.",
            "2) Décalage et Insertion : Le comparer aux éléments de la partie triée, ",
            "    décaler ceux qui sont plus grands vers la droite, ",
            "    et insérer l'élément à sa place correcte.",
            "3) Répéter le processus jusqu'à ce que tout le tableau soit trié.",
            "*/",
            "procédure ${1:tri_par_insertion}(@${2:T}: ${3:tab}, ${4:N}:entier)",
            "début",
            "\tpour i de 1 à ${4:N}-1 faire",
            "\t\ttemp <-- ${2:T}[i]",
            "\t\tj <-- i",
            "\t\t",
            "\t\ttant que j ≥ 1 et ${2:T}[j - 1] ${5|>,<|} temp faire",
            "\t\t\t${2:T}[j] <-- ${2:T}[j - 1]",
            "\t\t\tj <-- j - 1",
            "\t\tfin_tant_que",
            "\t\t",
            "\t\t${2:T}[j] <-- temp",
            "\tfin_pour",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i, j                               │ entier                   │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ temp                               │ ${6|entier   ,chaîne   ,réel     ,booléen  ,caractère|}                │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "(proc) tri par insertion"
    },
    "tri de Shell (v.1)": {
        "prefix": ["x-tri-shell-1"],
        "body": [
            "/*",
            "Principe du Tri de Shell:",
            "1) Tri par Insertion Distant : Réaliser un tri par insertion sur des sous-listes d'éléments",
            "   séparés par un écart (gap).",
            "2) Réduction Progressive : Réduire l'écart et répéter le tri distant.",
            "3) Finalisation : Terminer par un tri par insertion classique lorsque l'écart atteint 1.",
            "",
            "Remarque: Cette version utilise la séquence d'écarts originale proposée par Donald Shell en 1959 : ",
            "   gap initial = N div 2, puis division par 2 à chaque étape.",
            "*/",
            "procédure ${1:tri_shell}(@${2:T}: ${3:tab}, ${4:N}:entier)",
            "début",
            "\tgap <-- ${4:N} div 2",
            "\ttant que gap > 0 faire",
            "\t\tpour i de gap à ${4:N}-1 faire",
            "\t\t\ttemp <-- ${2:T}[i]",
            "\t\t\tj <-- i",
            "\t\t\t",
            "\t\t\ttant que j ≥ gap et ${2:T}[j - gap] ${5|>,<|} temp faire",
            "\t\t\t\t${2:T}[j] <-- ${2:T}[j - gap]",
            "\t\t\t\tj <-- j - gap",
            "\t\t\tfin_tant_que",
            "\t\t\t",
            "\t\t\t${2:T}[j] <-- temp",
            "\t\tfin_pour",
            "\t\tgap <-- gap div 2",
            "\tfin_tant_que",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i, j, gap                          │ entier                   │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ temp                               │ ${6|entier   ,chaîne   ,réel     ,booléen  ,caractère|}                │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "(proc) tri de Shell avec la séquence d'écarts (gaps) originale"
    },
    "tri de Shell (v.2)": {
        "prefix": ["x-tri-shell-2"],
        "body": [
            "/*",
            "Principe du Tri de Shell:",
            "1) Tri par Insertion Distant : Réaliser un tri par insertion sur des sous-listes d'éléments",
            "   séparés par un écart (gap).",
            "2) Réduction Progressive : Réduire l'écart et répéter le tri distant.",
            "3) Finalisation : Terminer par un tri par insertion classique lorsque l'écart atteint 1.",
            "",
            "Remarque: Cette version utilise la séquence d'écarts proposée par Donald Knuth :",
            "   on commence par le plus grand nombre généré par la suite gap = 3 * gap + 1,",
            "   puis on réduit l'écart à chaque étape avec gap = gap div 3, jusqu'à atteindre 1.",
            "*/",
            "procédure ${1:tri_shell}(@${2:T}: ${3:tab}, ${4:N}:entier)",
            "début",
            "\tgap <-- 1",
            "\ttant que gap < ${4:N} faire",
            "\t\tgap <-- 3 * gap + 1",
            "\tfin_tant_que",
            "",
            "\ttant que gap > 1 faire",
            "\t\tgap <-- gap div 3",
            "\t\tpour i de gap à ${4:N}-1 faire",
            "\t\t\ttemp <-- ${2:T}[i]",
            "\t\t\tj <-- i - gap",
            "\t\t\t",
            "\t\t\ttant que j ≥ 0 et ${2:T}[j] ${5|>,<|} temp faire",
            "\t\t\t\t${2:T}[j + gap] <-- ${2:T}[j]",
            "\t\t\t\tj <-- j - gap",
            "\t\t\tfin_tant_que",
            "\t\t\t",
            "\t\t\t${2:T}[j + gap] <-- temp",
            "\t\tfin_pour",
            "\tfin_tant_que",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i, j, gap                          │ entier                   │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ temp                               │ ${6|entier   ,chaîne   ,réel     ,booléen  ,caractère|}                │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "(proc) tri de Shell avec la séquence d'écarts (gaps) de Knuth"
    },
    "Recherche dichotomique": {
        "prefix": ["x-recherche-dichotomique"],
        "body": [
            "fonction ${1:recherche_dicho}(${2:T}: ${3:tab}, ${4:N}: entier, ${5:x}: ${6|entier,chaîne,réel  ,booléen,caractère|}): entier",
            "// Retourne l'indice de ${5:x}, ou -1 si non trouvé. ${2:T} doit être trié.",
            "début",
            "\tgauche <-- 0",
            "\tdroite <-- ${4:N} - 1",
            "\tindice_${5:x} <-- -1",
            "",
            "\ttant que gauche ≤ droite et indice_${5:x} = -1 faire",
            "\t\tmilieu <-- (gauche + droite) div 2",
            "\t\tsi ${2:T}[milieu] = ${5:x} alors",
            "\t\t\tindice_${5:x} <-- milieu",
            "\t\tsinon si ${5:x} < ${2:T}[milieu] alors",
            "\t\t\tdroite <-- milieu - 1",
            "\t\tsinon",
            "\t\t\tgauche <-- milieu + 1",
            "\t\tfin_si",
            "\tfin_tant_que",
            "",
            "\tretourner indice_${5:x}",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ gauche, droite, milieu, indice_${5:x}   │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "(fn) recherche dichotomique, retourne l'indice de l'élément à chercher"
    },
    "Recherche séquentielle": {
        "prefix": ["x-recherche-séquentielle"],
        "body": [
            "fonction ${1:recherche_séq}(${2:T}: ${3:tab}, ${4:N}: entier, ${5:x}: ${6|entier,chaîne,réel  ,booléen,caractère|}): booléen",
            "début",
            "\ti <-- 0",
            "\ttant que i < ${4:N} et ${2:T}[i] ≠ ${5:x} faire",
            "\t\ti <-- i + 1",
            "\tfin_tant_que",
            "\t// Test final : si la boucle s'est arrêtée avant la fin du tableau, ",
            "\t// c'est que ${2:T}[i] = ${5:x}.",
            "\tretourner i < ${4:N} ",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i                                  │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "(fn) recherche séquentielle, retourne un booléen "
    },
    "vérif. chaîne alphabétique": {
        "prefix": ["x-alpha"],
        "body": [
            "fonction ${1:alpha}(${2:ch}: chaîne) : booléen",
            "début",
            "\t${2:ch} <-- majus(${2:ch})",
            "\ti <-- 0",
            "\ttant que i < long(${2:ch}) et \"A\" ≤ ${2:ch}[i] ≤ \"Z\" faire",
            "\t\ti <-- i + 1",
            "\tfin_tant_que",
            "\t",
            "\tretourner i = long(${2:ch})",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i                                  │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "(fn) vérif. si une chaîne est composée uniquement par des lettres alphabétiques (v.1)"
    },
    "vérif. chaîne numérique": {
        "prefix": ["x-numérique"],
        "body": [
            "fonction ${1:est_numérique}(${2:ch}: chaîne) : booléen",
            "début",
            "\tnb_chiffres <-- 0",
            "\tpour i de 0 à long(${2:ch}) - 1 faire",
            "\t\tsi (${2:ch}[i] ≥ \"0\") et (${2:ch}[i] ≤ \"9\")  alors",
            "\t\t\tnb_chiffres <-- nb_chiffres + 1",
            "\t\tfin_si",
            "\tfin_pour",
            "",
            "\tsi nb_chiffres = long(${2:ch}) alors",
            "\t\tretourner vrai",
            "\tsinon",
            "\t\tretourner faux",
            "\tfin_si ",
            "\t// retourner nb_chiffres = long(${2:ch}) ",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i, nb_chiffres                     │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "(fn) vérif. si une chaîne est composée uniquement par des chiffres"
    },
    "fragment de code (py ou js)": {
        "prefix": ["x-code-source"],
        "body": ["```${1|python,javascript|}", "$0", "```"],
        "description": "ajout d'un fragment de code en python ou en javascript."
    }
}
