{
    "saisie contrôlée d'un nombre": {
        "prefix": ["x-saisir-N"],
        "body": [
            "procédure ${1:saisir}(@${2:N}: entier)",
            "début",
            "\trépéter",
            "\t\técrire(\"${3:Saisir N:} \") ",
            "\t\tlire(${2:N})",
            "\tjusqu'à  ${6:${4:5} ≤ ${2:N} ≤ ${5:20}}",
            "fin",
            ""
        ],
        "description": "procédure de saisie contrôlée d'un entier."
    },
    "remplissage d'un tableau": {
        "prefix": ["x-remplir-tableau"],
        "body": [
            "procédure ${1:remplir}(@${2:T}: ${3:tab}, ${4:N}: entier)",
            "début",
            "\tpour i de 0 à ${4:N}-1 faire",
            "\t\trépéter",
            "\t\t\técrire(\"${5:Nom} n°\", i, \": \") ",
            "\t\t\tlire(${2:T}[i]) ",
            "\t\tjusqu'à  ${6:long(${2:T}[i]) ≠ 0}",
            "\tfin_pour",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i                                  │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "procédure de remplissage interactif d'un tableau 1D avec validation des entrées."
    },
    "affichage d'un tableau": {
        "prefix": ["x-afficher-tableau"],
        "body": [
            "procédure ${1:afficher}(${2:T}: ${3:tab}, ${4:N}: entier)",
            "début",
            "\tpour i de 0 à ${4:N}-1 faire",
            "\t\técrire(\"${5:Case} n°\", i, \": \", ${2:T}[i])",
            "\tfin_pour",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i                                  │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "procédure d'affichage d'un tableau (1D)."
    },
    "remplissage d'une matrice carrée": {
        "prefix": ["x-remplir-matrice-carrée"],
        "body": [
            "procédure ${1:remplir}(@${2:T}: ${3:mat}, ${4:N}: entier)",
            "début",
            "\tpour i de 0 à ${4:N}-1 faire",
            "\t\tpour j de 0 à ${4:N}-1 faire",
            "\t\t\trépéter",
            "\t\t\t\técrire(\"${2:T}[\", i, \",\", j, \"]: \") ",
            "\t\t\t\tlire(${2:T}[i, j]) ",
            "\t\t\tjusqu'à  ${5:${2:T}[i, j] ≥ 0}",
            "\t\tfin_pour",
            "\tfin_pour",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i, j                               │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "procédure de remplissage interactif d'une matrice carrée avec validation des entrées."
    },
    "remplissage d'une matrice": {
        "prefix": ["x-remplir-matrice"],
        "body": [
            "procédure ${1:remplir}(@${2:T}: ${3:mat}, ${4:nb_lignes}, ${5:nb_colonnes}: entier)",
            "début",
            "\tpour i de 0 à ${4:nb_lignes}-1 faire",
            "\t\tpour j de 0 à ${5:nb_colonnes}-1 faire",
            "\t\t\trépéter",
            "\t\t\t\técrire(\"${2:T}[\", i, \",\", j, \"]: \") ",
            "\t\t\t\tlire(${2:T}[i, j]) ",
            "\t\t\tjusqu'à  ${6:${2:T}[i, j] ≥ 0}",
            "\t\tfin_pour",
            "\tfin_pour",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i, j                               │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "procédure de remplissage interactif d'une matrice avec validation des entrées."
    },
    "tri à bulles": {
        "prefix": ["x-tri-à-bulles"],
        "body": [
            "/*",
            "Principe du tri à bulles :",
            "1) Parcourir le tableau en comparant les éléments adjacents (voisins) deux à deux.",
            "\t- Si deux éléments adjacents ne sont pas ordonnés, les permuter (échanger de place).",
            "2) Répéter l'étape 1 jusqu'à ce qu'un parcours complet soit effectué sans aucune permutation.",
            "*/",
            "procédure ${1:tri_à_bulles}(@${2:T}: ${3:tab}, ${4:N}: entier)",
            "début",
            "\trépéter",
            "\t\taucune_permutation <-- vrai",
            "\t\tpour i de 0 à ${4:N}-2 faire",
            "\t\t\tsi ${2:T}[i] ${5|>,<|} ${2:T}[i+1] alors",
            "\t\t\t\t${6:aux} <-- ${2:T}[i]",
            "\t\t\t\t${2:T}[i] <-- ${2:T}[i+1]",
            "\t\t\t\t${2:T}[i+1] <-- ${6:aux}",
            "\t\t\t\taucune_permutation <-- faux",
            "\t\t\tfin_si",
            "\t\tfin_pour",
            "\tjusqu'à  aucune_permutation",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i                                  │ entier                   │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ aucune_permutation                 │ booléen                  │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ ${6:aux}                                │ ${7|entier   ,chaîne   ,réel     ,booléen  ,caractère|}                │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "procédure de tri à bulles avec optimisation (arrêt si trié)"
    },
    "tri par sélection (v.1)": {
        "prefix": ["x-tri-sélection-1"],
        "body": [
            "/*",
            "Principe du Tri par Sélection :",
            "1) Rechercher le plus petit élément dans la partie non triée du tableau (initialement à partir de la première position).",
            "   - Le placer, par permutation, à la position en cours (initialement la première position).",
            "2) Répéter l'étape 1 jusqu'à la fin du tableau.",
            "*/",
            "procédure ${1:tri_par_sélection}(@${2:T}: ${3:tab}, ${4:N}: entier)",
            "début",
            "\tpour i de 0 à ${4:N}-2 faire",
            "\t\t// recherche de la position du ${5|min,max|}imum",
            "\t\tpos_${5|min,max|} <-- i",
            "\t\tpour j de i+1 à ${4:N}-1 faire",
            "\t\t\tsi ${2:T}[j] ${6|<,>|} ${2:T}[pos_${5|min,max|}] alors",
            "\t\t\t\tpos_${5|min,max|} <-- j",
            "\t\t\tfin_si ",
            "\t\tfin_pour",
            "\t\t",
            "\t\t// permutation de la case actuelle (numéro i) avec ",
            "\t\t// la case qui contient le ${5|min,max|}imum (numéro pos_${5|min,max|})",
            "\t\tsi i ≠ pos_${5|min,max|} alors",
            "\t\t\t ${7:aux} <-- ${2:T}[i]",
            "\t\t\t${2:T}[i] <-- ${2:T}[pos_${5|min,max|}]",
            "\t\t\t${2:T}[pos_${5|min,max|}] <--  ${7:aux}",
            "\t\tfin_si",
            "\tfin_pour",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i, j, pos_${5|min,max|}                      │ entier                   │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ ${7:aux}                                │ ${8|entier   ,chaîne   ,réel     ,booléen  ,caractère|}                │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "procédure de tri par sélection (implémentation intégrée)"
    },
    "tri par sélection (v.2)": {
        "prefix": ["x-tri-sélection-2"],
        "body": [
            "/*",
            "Principe du tri par sélection :",
            "1) Rechercher, à partir de la [première position], le plus petit élément du tableau,",
            "   - Le placer, par permutation, à la [première position],",
            "2) Répéter l'étape 1 à partir de la [deuxième position], et ainsi de suite jusqu'à la fin du tableau.",
            "*/",
            "procédure ${1:tri_par_sélection}(@${2:T}: ${3:tab}, ${4:N}: entier)",
            "début",
            "\tpour i de 0 à ${4:N}-2 faire",
            "\t\tpos_${5|min,max|} <-- chercher_pos_${5|min,max|}(${2:T}, i, ${4:N}-1)",
            "\t\tpermuter(${2:T}[i], ${2:T}[pos_${5|min,max|}])",
            "\tfin_pour\t\t",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i, pos_${5|min,max|}                         │ entier                   │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ chercher_pos_${5|min,max|}                   │ fonction                 │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ permuter                           │ procédure                │",
            "└────────────────────────────────────┴──────────────────────────┘",
            "",
            "fonction chercher_pos_${5|min,max|}(${2:T}: ${3:tab}, b_ini, b_fin: entier) : entier",
            "début",
            "\tpos_${5|min,max|} <-- b_ini",
            "\tpour i de b_ini + 1 à b_fin faire",
            "\t\tsi ${2:T}[i] ${6|<,>|} ${2:T}[pos_${5|min,max|}] alors",
            "\t\t\tpos_${5|min,max|} <-- i",
            "\t\tfin_si",
            "\tfin_pour",
            "\tretourner pos_${5|min,max|}",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i, pos_${5|min,max|}                         │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            "",
            "",
            "procédure permuter(@x, @y: ${8|entier   ,chaîne   ,réel     ,booléen  ,caractère|})",
            "début",
            "\taux <-- x",
            "\tx <-- y",
            "\ty <-- aux",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ aux                                │ ${8|entier   ,chaîne   ,réel     ,booléen  ,caractère|}                │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "procédure de tri par sélection (implémentation modulaire)"
    },
    "tri par insertion": {
        "prefix": ["x-tri-insertion"],
        "body": [
            "/*",
            "Principe du Tri par Insertion :",
            "1) Prendre le premier élément de la partie non triée.",
            "2) Le comparer aux éléments de la partie triée, ",
            "    décaler ceux qui sont plus grands vers la droite, ",
            "    et insérer l'élément à sa place correcte.",
            "3) Répéter les étapes 1 et 2 jusqu'à ce que tout le tableau soit trié.",
            "*/",
            "procédure ${1:tri_par_insertion}(@${2:T}: ${3:tab}, ${4:N}: entier)",
            "début",
            "\tpour i de 1 à ${4:N}-1 faire",
            "\t\ttemp <-- ${2:T}[i]",
            "\t\tj <-- i",
            "\t\t",
            "\t\ttant que j ≥ 1 et ${2:T}[j - 1] ${5|>,<|} temp faire",
            "\t\t\t${2:T}[j] <-- ${2:T}[j - 1]",
            "\t\t\tj <-- j - 1",
            "\t\tfin_tant_que",
            "\t\t",
            "\t\t${2:T}[j] <-- temp",
            "\tfin_pour",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i, j                               │ entier                   │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ temp                               │ ${6|entier   ,chaîne   ,réel     ,booléen  ,caractère|}                │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "procédure de tri par insertion"
    },
    "tri de Shell (v.1)": {
        "prefix": ["x-tri-shell-1"],
        "body": [
            "/*",
            "Principe du Tri de Shell:",
            "1) Tri par Insertion Distant : Réaliser un tri par insertion sur des sous-listes d'éléments",
            "   séparés par un écart (gap).",
            "2) Réduction Progressive : Réduire l'écart et répéter le tri distant.",
            "3) Finalisation : Terminer par un tri par insertion classique lorsque l'écart atteint 1.",
            "",
            "Remarque: Cette version utilise la séquence d'écarts originale proposée par Donald Shell en 1959 : ",
            "   gap initial = N div 2, puis division par 2 à chaque étape.",
            "*/",
            "procédure ${1:tri_shell}(@${2:T}: ${3:tab}, ${4:N}: entier)",
            "début",
            "\tgap <-- ${4:N} div 2",
            "\ttant que gap > 0 faire",
            "\t\tpour i de gap à ${4:N}-1 faire",
            "\t\t\ttemp <-- ${2:T}[i]",
            "\t\t\tj <-- i",
            "\t\t\t",
            "\t\t\ttant que j ≥ gap et ${2:T}[j - gap] ${5|>,<|} temp faire",
            "\t\t\t\t${2:T}[j] <-- ${2:T}[j - gap]",
            "\t\t\t\tj <-- j - gap",
            "\t\t\tfin_tant_que",
            "\t\t\t",
            "\t\t\t${2:T}[j] <-- temp",
            "\t\tfin_pour",
            "\t\tgap <-- gap div 2",
            "\tfin_tant_que",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i, j, gap                          │ entier                   │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ temp                               │ ${6|entier   ,chaîne   ,réel     ,booléen  ,caractère|}                │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "procédure de tri de Shell avec la séquence d'écarts (gaps) originale"
    },
    "tri de Shell (v.2)": {
        "prefix": ["x-tri-shell-2"],
        "body": [
            "/*",
            "Principe du Tri de Shell:",
            "1) Tri par Insertion Distant : Réaliser un tri par insertion sur des sous-listes d'éléments",
            "   séparés par un écart (gap).",
            "2) Réduction Progressive : Réduire l'écart et répéter le tri distant.",
            "3) Finalisation : Terminer par un tri par insertion classique lorsque l'écart atteint 1.",
            "",
            "Remarque: Cette version utilise la séquence d'écarts proposée par Donald Knuth :",
            "   on commence par le plus grand nombre généré par la suite gap = 3 * gap + 1,",
            "   puis on réduit l'écart à chaque étape avec gap = gap div 3, jusqu'à atteindre 1.",
            "*/",
            "procédure ${1:tri_shell}(@${2:T}: ${3:tab}, ${4:N}: entier)",
            "début",
            "\tgap <-- 1",
            "\ttant que gap < ${4:N} faire",
            "\t\tgap <-- 3 * gap + 1",
            "\tfin_tant_que",
            "",
            "\ttant que gap > 1 faire",
            "\t\tgap <-- gap div 3",
            "\t\tpour i de gap à ${4:N}-1 faire",
            "\t\t\ttemp <-- ${2:T}[i]",
            "\t\t\tj <-- i - gap",
            "\t\t\t",
            "\t\t\ttant que j ≥ 0 et ${2:T}[j] ${5|>,<|} temp faire",
            "\t\t\t\t${2:T}[j + gap] <-- ${2:T}[j]",
            "\t\t\t\tj <-- j - gap",
            "\t\t\tfin_tant_que",
            "\t\t\t",
            "\t\t\t${2:T}[j + gap] <-- temp",
            "\t\tfin_pour",
            "\tfin_tant_que",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i, j, gap                          │ entier                   │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ temp                               │ ${6|entier   ,chaîne   ,réel     ,booléen  ,caractère|}                │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "procédure de tri de Shell avec la séquence d'écarts (gaps) de Knuth"
    },
    "Recherche dichotomique": {
        "prefix": ["x-recherche-dichotomique"],
        "body": [
            "fonction ${1:recherche_dicho}(${2:T}: ${3:tab}, ${4:N}: entier, ${5:x}: ${6|entier,chaîne,réel  ,booléen,caractère|}): entier",
            "// Retourne l'indice de ${5:x}, ou -1 si non trouvé. ${2:T} doit être trié.",
            "début",
            "\tgauche <-- 0",
            "\tdroite <-- ${4:N} - 1",
            "\tindice_${5:x} <-- -1",
            "",
            "\ttant que gauche ≤ droite et indice_${5:x} = -1 faire",
            "\t\tmilieu <-- (gauche + droite) div 2",
            "\t\tsi ${2:T}[milieu] = ${5:x} alors",
            "\t\t\tindice_${5:x} <-- milieu",
            "\t\tsinon si ${5:x} < ${2:T}[milieu] alors",
            "\t\t\tdroite <-- milieu - 1",
            "\t\tsinon",
            "\t\t\tgauche <-- milieu + 1",
            "\t\tfin_si",
            "\tfin_tant_que",
            "",
            "\tretourner indice_${5:x}",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ gauche, droite, milieu, indice_${5:x}   │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "fonction de recherche dichotomique : retourne l'indice ou -1 si absent."
    },
    "Recherche séquentielle": {
        "prefix": ["x-recherche-séquentielle"],
        "body": [
            "fonction ${1:recherche_séq}(${2:T}: ${3:tab}, ${4:N}: entier, ${5:x}: ${6|entier,chaîne,réel  ,booléen,caractère|}): booléen",
            "début",
            "\ti <-- 0",
            "\ttant que i < ${4:N} et ${2:T}[i] ≠ ${5:x} faire",
            "\t\ti <-- i + 1",
            "\tfin_tant_que",
            "\t// Test final : si la boucle s'est arrêtée avant la fin du tableau, ",
            "\t// c'est que ${2:T}[i] = ${5:x}.",
            "\tretourner i < ${4:N} ",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i                                  │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "fonction de recherche séquentielle : retourne vrai si trouvé, faux sinon."
    },
    "vérif. chaîne alphabétique": {
        "prefix": ["x-alpha"],
        "body": [
            "fonction ${1:alpha}(${2:ch}: chaîne) : booléen",
            "début",
            "\t${2:ch} <-- majus(${2:ch})",
            "\ti <-- 0",
            "\ttant que i < long(${2:ch}) et \"A\" ≤ ${2:ch}[i] ≤ \"Z\" faire",
            "\t\ti <-- i + 1",
            "\tfin_tant_que",
            "\t",
            "\tretourner i = long(${2:ch})",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i                                  │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "fonction vérifiant si une chaîne est alphabétique."
    },
    "vérif. chaîne numérique": {
        "prefix": ["x-numérique"],
        "body": [
            "fonction ${1:est_numérique}(${2:ch}: chaîne) : booléen",
            "début",
            "\tnb_chiffres <-- 0",
            "\tpour i de 0 à long(${2:ch}) - 1 faire",
            "\t\tsi \"0\" ≤ ${2:ch}[i] ≤ \"9\"  alors",
            "\t\t\tnb_chiffres <-- nb_chiffres + 1",
            "\t\tfin_si",
            "\tfin_pour",
            "",
            "\tsi nb_chiffres = long(${2:ch}) alors",
            "\t\tretourner vrai",
            "\tsinon",
            "\t\tretourner faux",
            "\tfin_si ",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i, nb_chiffres                     │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "fonction vérifiant si une chaîne contient uniquement des chiffres."
    },
    "calcul de factorielle": {
        "prefix": ["x-factorielle"],
        "body": [
            "fonction ${1:factorielle}(${2:N}: entier): entier",
            "début",
            "\tf <-- 1",
            "\tpour i de 2 à ${2:N} faire",
            "\t\tf <-- f * i",
            "\tfin_pour",
            "\tretourner f",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i, f                               │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": [
            "fonction de calcul de la factorielle d'un entier N (N!).",
            "",
            "- Formule : N! = 1 * 2 * 3 * ... * N",
            "- Cas particulier : 0! = 1 (géré automatiquement)",
            "- Précondition : N ≥ 0",
            "- Exemple : factorielle(5) → 120"
        ]
    },
    "calcul de factorielle (récursif)": {
        "prefix": ["x-factorielle-rec"],
        "body": [
            "fonction ${1:factorielle}(${2:N}: entier): entier",
            "début",
            "\tsi ${2:N} = 0 alors",
            "\t\tretourner 1",
            "\tsinon",
            "\t\tretourner ${2:N} * ${1:factorielle}(${2:N} - 1)",
            "\tfin_si",
            "fin",
            ""
        ],
        "description": [
            "fonction récursive qui calcule la factorielle d'un entier N (N!)",
            "",
            "- Formule récursive : N! = N * (N-1)!",
            "- Cas de base : 0! = 1",
            "- Précondition : N ≥ 0",
            "- Exemple : factorielle(5) → 5 * 4 * 3 * 2 * 1 = 120"
        ]
    },
    "calcul de puissance": {
        "prefix": ["x-puissance"],
        "body": [
            "fonction ${1:puissance}(${2:x}: réel, ${3:n}: entier): réel",
            "début",
            "\tp <-- 1",
            "\tpour i de 1 à abs(${3:n}) faire",
            "\t\tp <-- p * ${2:x}",
            "\tfin_pour",
            "\tsi ${3:n} ≥ 0 alors",
            "\t\tretourner p",
            "\tsinon",
            "\t\tretourner 1 / p",
            "\tfin_si",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i                                  │ entier                   │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ p                                  │ réel                     │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": [
            "fonction qui calcule x^n, avec x réel et n entier.",
            "",
            "- Formule : x^n = x * x * ... * x (n fois)",
            "- Cas particuliers :",
            "  • x^0 = 1 (géré automatiquement)",
            "  • x^(-n) = 1 / x^n",
            "- Précondition : si n < 0, alors x ≠ 0",
            "- Exemples :",
            "  • puissance(-2, 3) → -8",
            "  • puissance(2, -3) → 0.125",
            "  • puissance(5, 0)  → 1"
        ]
    },
    "calcul de puissance (récursif)": {
        "prefix": ["x-puissance-rec"],
        "body": [
            "fonction ${1:puissance}(${2:x}: réel, ${3:n}: entier): réel",
            "début",
            "\tsi ${3:n} = 0 alors",
            "\t\tretourner 1",
            "\tsinon si ${3:n} > 0 alors",
            "\t\tretourner ${2:x} * ${1:puissance}(${2:x}, ${3:n} - 1)",
            "\tsinon",
            "\t\tretourner 1 / ${1:puissance}(${2:x}, -${3:n})",
            "\tfin_si",
            "fin",
            ""
        ],
        "description": [
            "fonction récursive qui calcule x^n, avec x réel et n entier.",
            "",
            "- Définition récursive :",
            "  • x^n = x * x^(n-1)  (si n > 0)",
            "  • x^n = 1 / x^(-n)   (si n < 0)",
            "- Cas de base :",
            "  • x^0 = 1",
            "",
            "- Précondition : si n < 0, alors x ≠ 0",
            "- Exemples :",
            "  • puissance(-2, 3) → -8",
            "  • puissance(2, -3) → 0.125",
            "  • puissance(5, 0)  → 1"
        ]
    },
    "vérification nombre premier (naïve)": {
        "prefix": ["x-premier-naif"],
        "body": [
            "fonction ${1:premier}(${2:n}: entier): booléen",
            "début",
            "\tnb_diviseurs <-- 0",
            "\tpour i de 1 à ${2:n} faire",
            "\t\tsi ${2:n} mod i = 0 alors",
            "\t\t\tnb_diviseurs <-- nb_diviseurs + 1",
            "\t\tfin_si",
            "\tfin_pour",
            "\tretourner nb_diviseurs = 2",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i, nb_diviseurs                    │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": [
            "fonction qui vérifie si un entier n est premier (version naïve).",
            "",
            "- Principe : compte le nombre de diviseurs de n.",
            "- Un nombre premier a exactement 2 diviseurs (1 et lui-même).",
            "- Précondition : n ≥ 0",
            "- Cas particuliers :",
            "  • n = 1 → non premier (1 seul diviseur)",
            "  • n = 2 → premier (2 diviseurs)",
            "- Exemples :",
            "  • premier(7) → vrai (diviseurs : 1, 7)",
            "  • premier(9) → faux (diviseurs : 1, 3, 9)",
            "  • premier(1) → faux (diviseurs : 1)"
        ]
    },
    "vérification nombre premier (optimisée)": {
        "prefix": ["x-premier-opt"],
        "body": [
            "fonction ${1:premier}(${2:n}: entier): booléen",
            "début",
            "\ti <-- 2",
            "\ttant que ${2:n} mod i ≠ 0 et i * i ≤ ${2:n} faire",
            "\t\ti <-- i + 1",
            "\tfin_tant_que",
            "\tretourner (i * i > ${2:n}) et (${2:n} > 1)",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i                                  │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": [
            "fonction qui vérifie si un entier n est premier (version optimisée).",
            "",
            "- Principe : teste les diviseurs jusqu'à √n.",
            "- Précondition : n ≥ 0",
            "- Cas particuliers :",
            "  • n = 1 → non premier (1 seul diviseur)",
            "  • n = 2 → premier (2 diviseurs)",
            "- Exemples :",
            "  • premier(7) → vrai",
            "  • premier(9) → faux",
            "  • premier(1) → faux"
        ]
    },
    "décomposition en facteurs premiers": {
        "prefix": ["x-facteurs-premiers"],
        "body": [
            "fonction ${1:facteurs_premiers}(N: entier): chaîne",
            "début",
            "\tch <-- \"\"",
            "\td <-- 2",
            "\ttant que N > 1 faire",
            "\t\tsi N mod d = 0 alors",
            "\t\t\tch <-- ch + convch(d) + \"*\"",
            "\t\t\tN <-- N div d",
            "\t\tsinon",
            "\t\t\td <-- d + 1",
            "\t\tfin_si",
            "\tfin_tant_que",
            "\tretourner sous_chaîne(ch, 0, long(ch) - 1)",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ ch                                 │ chaîne                   │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ d                                  │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": [
            "fonction qui décompose un entier en produit de facteurs premiers.",
            "",
            "- Principe :",
            "  • Tester la divisibilité par les entiers à partir de 2",
            "  • Si divisible, ajouter le facteur et diviser N",
            "  • Sinon, passer au nombre suivant",
            "  • S'arrêter quand N = 1",
            "",
            "- Propriétés :",
            "  • Les facteurs sont trouvés dans l'ordre croissant",
            "  • Un facteur premier peut apparaître plusieurs fois",
            "  • Le symbole '*' sépare les facteurs",
            "",
            "- Précondition : N ≥ 2",
            "",
            "- Exemples :",
            "  • facteurs_premiers(12) → \"2*2*3\"",
            "  • facteurs_premiers(17) → \"17\"",
            "  • facteurs_premiers(100) → \"2*2*5*5\"",
            "  • facteurs_premiers(91) → \"7*13\""
        ]
    },

    "calcul du PGCD (méthode des différences)": {
        "prefix": ["x-pgcd-diff"],
        "body": [
            "fonction ${1:pgcd}(a: entier, b: entier): entier",
            "début",
            "\ttant que a ≠ b faire",
            "\t\tsi a > b alors",
            "\t\t\ta <-- a - b",
            "\t\tsinon",
            "\t\t\tb <-- b - a",
            "\t\tfin_si",
            "\tfin_tant_que",
            "\tretourner a",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ a, b                               │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": [
            "fonction qui calcule le PGCD par la méthode des différences.",
            "",
            "- Principe mathématique :",
            "  • Si a = b, alors PGCD(a, b) = a.",
            "  • Si a > b, alors PGCD(a, b) = PGCD(a - b, b).",
            "  • Si a < b, alors PGCD(a, b) = PGCD(a, b - a).",
            "",
            "- Précondition : a > 0 et b > 0.",
            "",
            "- Exemple détaillé pour PGCD(28, 42) :",
            "  • 28 < 42, donc PGCD(28, 42) = PGCD(28, 42 - 28) = PGCD(28, 14)",
            "  • 28 > 14, donc PGCD(28, 14) = PGCD(28 - 14, 14) = PGCD(14, 14)",
            "  • 14 = 14, donc PGCD(14, 14) = 14",
            "",
            "- Exemples :",
            "  • pgcd(48, 18) → 6",
            "  • pgcd(17, 13) → 1"
        ]
    },
    "calcul du PGCD (algorithme d'Euclide)": {
        "prefix": ["x-pgcd-euclide"],
        "body": [
            "fonction ${1:pgcd}(a: entier, b: entier): entier",
            "début",
            "\ttant que b ≠ 0 faire",
            "\t\tr <-- a mod b",
            "\t\ta <-- b",
            "\t\tb <-- r",
            "\tfin_tant_que",
            "\tretourner a",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ a, b, r                            │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": [
            "fonction qui calcule le PGCD par l'algorithme d'Euclide.",
            "",
            "- Principe mathématique :",
            "  • PGCD(a, b) = PGCD(b, a mod b), tant que b ≠ 0.",
            "  • Quand b = 0, alors PGCD(a, 0) = a.",
            "",
            "- Précondition : a ≥ 0, b ≥ 0, et a+b > 0 (pour éviter pgcd(0,0))",
            "",
            "- Exemple détaillé pour PGCD(48, 18) :",
            "  • PGCD(48, 18) = PGCD(18, 48 mod 18) = PGCD(18, 12)",
            "  • PGCD(18, 12) = PGCD(12, 18 mod 12) = PGCD(12, 6)",
            "  • PGCD(12, 6) = PGCD(6, 12 mod 6) = PGCD(6, 0) = 6",
            "",
            "- Avantage : plus rapide que la méthode des différences",
            "",
            "- Exemples :",
            "  • pgcd(48, 18) → 6",
            "  • pgcd(17, 13) → 1",
            "  • pgcd(15, 0) → 15"
        ]
    },
    "calcul du PGCD (méthode des différences récursive)": {
        "prefix": ["x-pgcd-diff-rec"],
        "body": [
            "fonction ${1:pgcd}(a: entier, b: entier): entier",
            "début",
            "\tsi a = b alors",
            "\t\tretourner a",
            "\tsinon si a > b alors",
            "\t\tretourner ${1:pgcd}(a - b, b)",
            "\tsinon",
            "\t\tretourner ${1:pgcd}(a, b - a)",
            "\tfin_si",
            "fin",
            ""
        ],
        "description": [
            "fonction récursive qui calcule le PGCD par la méthode des différences.",
            "",
            "- Définition récursive :",
            "  • Si a > b, alors PGCD(a, b) = PGCD(a - b, b).",
            "  • Si a < b, alors PGCD(a, b) = PGCD(a, b - a).",
            "- Cas de base :",
            "  • a = b, alors PGCD(a, b) = a",
            "",
            "- Précondition : a > 0 et b > 0.",
            "",
            "- Exemple détaillé pour PGCD(28, 42) :",
            "  • pgcd(28, 42) → pgcd(28, 14)",
            "  • pgcd(28, 14) → pgcd(14, 14)",
            "  • pgcd(14, 14) → 14",
            "",
            "- Exemples :",
            "  • pgcd(48, 18) → 6",
            "  • pgcd(17, 13) → 1"
        ]
    },
    "calcul du PGCD (algorithme d'Euclide récursif)": {
        "prefix": ["x-pgcd-euclide-rec"],
        "body": [
            "fonction ${1:pgcd}(a: entier, b: entier): entier",
            "début",
            "\tsi b = 0 alors",
            "\t\tretourner a",
            "\tsinon",
            "\t\tretourner ${1:pgcd}(b, a mod b)",
            "\tfin_si",
            "fin",
            ""
        ],
        "description": [
            "fonction récursive qui calcule le PGCD par l'algorithme d'Euclide.",
            "",
            "- Définition récursive :",
            "  • Si b ≠ 0, alors PGCD(a, b) = PGCD(b, a mod b).",
            "- Cas de base :",
            "  • b = 0, alors PGCD(a, 0) = a",
            "",
            "- Précondition : a ≥ 0, b ≥ 0, et a + b > 0",
            "",
            "- Exemple détaillé pour PGCD(48, 18) :",
            "  • pgcd(48, 18) → pgcd(18, 12)",
            "  • pgcd(18, 12) → pgcd(12, 6)",
            "  • pgcd(12, 6) → pgcd(6, 0) → 6",
            "",
            "- Exemples :",
            "  • pgcd(48, 18) → 6",
            "  • pgcd(17, 13) → 1",
            "  • pgcd(15, 0) → 15"
        ]
    },
    "calcul du PPCM": {
        "prefix": ["x-ppcm"],
        "body": [
            "fonction ${1:ppcm}(a: entier, b: entier): entier",
            "début",
            "\tretourner (a * b) div pgcd(a, b)",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ pgcd                               │ fonction                 │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": [
            "fonction qui calcule le PPCM de deux entiers a et b.",
            "",
            "- Principe : Utilise la relation fondamentale entre le PPCM et le PGCD :",
            "  • a * b = PPCM(a, b) * PGCD(a, b).",
            "  • d'où : PPCM(a, b) = (a * b) / PGCD(a, b)",
            "",
            "- Précondition : a > 0, b > 0",
            "",
            "- Exemples :",
            "  • ppcm(12, 18) → 36  (car 12*18 div 6 = 36)",
            "  • ppcm(7, 5) → 35"
        ]
    },
    "calcul du PPCM (méthode des multiples)": {
        "prefix": ["x-ppcm-naif"],
        "body": [
            "fonction ${1:ppcm}(a: entier, b: entier): entier",
            "début",
            "\tres <-- a",
            "\ttant que res mod b ≠ 0 faire",
            "\t\tres <-- res + a",
            "\tfin_tant_que",
            "\tretourner res",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ res                                │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": [
            "fonction qui calcule le PPCM par la méthode des multiples (version naïve).",
            "",
            "- Principe :",
            "  • Parcourir les multiples de a dans l'ordre croissant :",
            "    a, 2a, 3a, 4a, ...",
            "  • S'arrêter au premier multiple qui est aussi divisible par b",
            "",
            "- Précondition : a > 0 et b > 0.",
            "- Inconvénient : lent si a et b sont grands et premiers entre eux.",
            "",
            "- Exemple détaillé pour PPCM(4, 6) :",
            "  • Multiples de 4 : 4, 8, 12, ...",
            "  • 4 mod 6 = 4 ≠ 0 → continuer",
            "  • 8 mod 6 = 2 ≠ 0 → continuer",
            "  • 12 mod 6 = 0 → PPCM = 12",
            "",
            "- Exemples :",
            "  • ppcm(4, 6) → 12",
            "  • ppcm(3, 7) → 21",
            "  • ppcm(5, 10) → 10"
        ]
    },
    "vérification palindrome": {
        "prefix": ["x-palindrome"],
        "body": [
            "fonction ${1:palindrome}(ch: chaîne): booléen",
            "début",
            "\ti <-- 0",
            "\tj <-- long(ch) - 1",
            "\ttant que i < j et ch[i] = ch[j] faire",
            "\t\ti <-- i + 1",
            "\t\tj <-- j - 1",
            "\tfin_tant_que",
            "\tretourner i ≥ j",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i, j                               │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": [
            "fonction qui vérifie si une chaîne est un palindrome.",
            "",
            "- Propriétés :",
            "  • Un palindrome se lit de la même façon de gauche à droite",
            "    et de droite à gauche",
            "  • La chaîne vide et les chaînes d'un seul caractère sont des palindromes",
            "  • La casse est prise en compte (\"A\" ≠ \"a\").",
            "",
            "- Principe :",
            "  • Comparer les caractères symétriques en partant des extrémités",
            "    de la chaîne vers le centre.",
            "  • S'arrêter dès qu'une différence est trouvée ou que les pointeurs se croisent.",
            "",
            "- Exemples :",
            "  • palindrome(\"ici\") → vrai",
            "  • palindrome(\"ressasser\") → vrai",
            "  • palindrome(\"bonjour\") → faux",
            "  • palindrome(\"Radar\") → faux  (car 'R' ≠ 'r')"
        ]
    },
    "vérification palindrome (récursif)": {
        "prefix": ["x-palindrome-rec"],
        "body": [
            "fonction ${1:palindrome}(ch: chaîne): booléen",
            "début",
            "\tsi long(ch) ≤ 1 alors",
            "\t\tretourner vrai",
            "\tsinon si ch[0] ≠ ch[long(ch) - 1] alors",
            "\t\tretourner faux",
            "\tsinon",
            "\t\tretourner ${1:palindrome}(sous_chaîne(ch, 1, long(ch) - 1))",
            "\tfin_si",
            "fin",
            ""
        ],
        "description": [
            "fonction récursive qui vérifie si une chaîne est un palindrome.",
            "",
            "- Définition récursive :",
            "  • Cas de base : chaîne vide ou d'un seul caractère → vrai.",
            "  • Cas récursif :",
            "      premier caractère = dernier caractère",
            "      ET le reste (sans les extrémités) est un palindrome.",
            "",
            "- Propriétés :",
            "  • Sensible à la casse (\"A\" ≠ \"a\").",
            "",
            "- Exemple détaillé pour \"ressasser\" :",
            "  • palindrome(\"ressasser\")",
            "    → \"r\"=\"r\" et palindrome(\"essasse\")",
            "    → \"e\"=\"e\" et palindrome(\"ssass\")",
            "    → \"s\"=\"s\" et palindrome(\"sas\")",
            "    → \"s\"=\"s\" et palindrome(\"a\") → vrai",
            "",
            "- Exemples :",
            "  • palindrome(\"ici\") → vrai",
            "  • palindrome(\"bonjour\") → faux",
            "  • palindrome(\"Radar\") → faux (car \"R\" ≠ \"r\")"
        ]
    },
    "conversion base 10 vers base b": {
        "prefix": ["x-conversion-b10-base"],
        "body": [
            "fonction ${1:conv_10_b}(n: entier, b: entier): chaîne",
            "début",
            "\tchiffres <-- \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"",
            "\tresultat <-- \"\"",
            "\trépéter",
            "\t\tresultat <-- chiffres[n mod b] + resultat",
            "\t\tn <-- n div b",
            "\tjusqu'à n = 0",
            "\tretourner resultat",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ chiffres, resultat                 │ chaîne                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": [
            "fonction qui convertit un nombre décimal (base 10) en base b (2 ≤ b ≤ 36).",
            "",
            "- Principe :",
            "  • Division successive par la base b",
            "  • Les restes donnent les chiffres de droite à gauche",
            "  • Les restes (0 à 35) sont convertis en caractères via la chaîne \"0123...YZ\".",
            "",
            "- Préconditions :",
            "  • n ≥ 0",
            "  • 2 ≤ b ≤ 36",
            "",
            "- Cas particulier :",
            "  • n = 0 → retourne \"0\"",
            "",
            "- Exemples :",
            "  • conv_10_b(42, 2) → \"101010\"",
            "  • conv_10_b(255, 16) → \"FF\"",
            "  • conv_10_b(100, 8) → \"144\"",
            "  • conv_10_b(35, 36) → \"Z\""
        ]
    },
    "conversion base b vers base 10": {
        "prefix": ["x-conversion-base-b10"],
        "body": [
            "fonction ${1:conv_b_10}(ch: chaîne, b: entier): entier",
            "début",
            "\tchiffres <-- \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"",
            "\tn <-- 0",
            "\tpour i de 0 à long(ch) - 1 faire",
            "\t\tn <-- n * b + pos(ch[i], chiffres)",
            "\tfin_pour",
            "\tretourner n",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ chiffres                           │ chaîne                   │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i, n                               │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": [
            "fonction qui convertit un nombre en base b (2 ≤ b ≤ 36) vers la base 10 (décimal).",
            "",
            "- Principe :",
            "  • Méthode de Horner : parcourir les chiffres de gauche à droite",
            "  • À chaque étape : n = n * b + valeur_du_chiffre",
            "  • Les caractères \"0-9\" et \"A-Z\" sont convertis en valeurs via pos().",
            "",
            "- Préconditions :",
            "  • ch doit contenir uniquement des caractères valides pour la base b",
            "  • 2 ≤ b ≤ 36",
            "",
            "- Exemples :",
            "  • conv_b_10(\"101010\", 2) → 42",
            "  • conv_b_10(\"FF\", 16) → 255",
            "  • conv_b_10(\"144\", 8) → 100",
            "  • conv_b_10(\"Z\", 36) → 35"
        ]
    },
    "transfert tableau vers fichier": {
        "prefix": ["x-transfert-t-vers-f"],
        "body": [
            "procédure ${1:t_vers_f}(${2:T}: ${3:Tab}, ${4:N}: entier, @${5:f}: ${6:TFichier})",
            "début",
            "\tpour i de 0 à ${4:N} - 1 faire",
            "\t\técrire(${5:f}, ${2:T}[i])",
            "\tfin_pour",
            "fin",
            "",
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ i                                  │ entier                   │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": [
            "procédure de transfert du contenu d'un tableau vers un fichier typé.",
            "",
            "- Principe :",
            "  • Parcourir le tableau de l'indice 0 à N-1",
            "  • Écrire chaque élément dans le fichier",
            "",
            "- Préconditions :",
            "  • Le fichier doit être ouvert en mode écriture (\"wb\" ou \"ab\")",
            "  • Les éléments du tableau et du fichier doivent être de même type",
            "",
            "- Exemple d'utilisation :",
            "  ouvrir(\"donnees.dat\", f, \"wb\")",
            "  t_vers_f(T, N, f)",
            "  fermer(f)"
        ]
    },
    "transfert fichier vers tableau": {
        "prefix": ["x-transfert-f-vers-t"],
        "body": [
            "procédure ${1:f_vers_t}(@${2:T}: ${3:Tab}, @${4:N}: entier, @${5:f}: ${6:TFichier})",
            "début",
            "\t${4:N} <-- 0",
            "\ttant que non fin_fichier(${5:f}) faire",
            "\t\tlire(${5:f}, ${2:T}[${4:N}])",
            "\t\t${4:N} <-- ${4:N} + 1",
            "\tfin_tant_que",
            "fin",
            ""
        ],
        "description": [
            "procédure de transfert du contenu d'un fichier typé vers un tableau.",
            "",
            "- Principe :",
            "  • Lire le fichier jusqu'à la fin",
            "  • Stocker chaque élément dans le tableau",
            "  • Compter le nombre d'éléments lus dans N",
            "",
            "- Préconditions :",
            "  • Le fichier doit être ouvert en mode lecture (\"rb\")",
            "  • Les éléments du fichier et du tableau doivent être de même type",
            "  • Le tableau doit être suffisamment grand pour contenir tous les éléments",
            "",
            "- Exemple d'utilisation :",
            "  ouvrir(\"donnees.dat\", f, \"rb\")",
            "  f_vers_t(T, N, f)",
            "  fermer(f)"
        ]
    },
    "fragment de code (py ou js)": {
        "prefix": ["x-code-source"],
        "body": ["```${1|python,javascript|}", "$0", "```"],
        "description": "insertion d'un fragment de code Python ou JavaScript."
    }
}
