{
    "algorithme": {
        "prefix": ["algorithme"],
        "body": ["algorithme ${1:nom}", "début", "\t$0", "fin"],
        "description": "Structure de base d'un algorithme : entête, début et fin."
    },
    "fonction (définition)": {
        "prefix": ["fonction", "fn"],
        "body": [
            "fonction ${1:nom}(${2:paramètres_formels}) : ${3|entier,chaîne,réel,booléen,caractère|}",
            "début",
            "\t$0",
            "fin"
        ],
        "description": "Définit une fonction : sous-programme qui calcule et renvoie une valeur."
    },
    "procédure (définition)": {
        "prefix": ["procédure", "proc"],
        "body": [
            "procédure ${1:nom}(${2:paramètres_formels})",
            "début",
            "\t$0",
            "fin"
        ],
        "description": "Définit une procédure : sous-programme qui exécute des actions sans renvoyer de valeur."
    },
    "tdo: 1 ligne": {
        "prefix": "tdo-1",
        "body": [
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ ${1:x}                                  │ ${2|entier       ,chaîne       ,réel         ,booléen      ,caractère    ,fonction     ,procédure    ,fichier texte|}            │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "tableau de déclaration des objets"
    },
    "tdo: 3 lignes": {
        "prefix": "tdo-3",
        "body": [
            "┌────────────────────────────────────┬──────────────────────────┐",
            "│               Objet                │      Nature / Type       │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ ${1:x}                                  │ ${2|entier       ,chaîne       ,réel         ,booléen      ,caractère    ,fonction     ,procédure    ,fichier texte|}            │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ ${3:y}                                  │ ${4|entier       ,chaîne       ,réel         ,booléen      ,caractère    ,fonction     ,procédure    ,fichier texte|}            │",
            "├────────────────────────────────────┼──────────────────────────┤",
            "│ ${5:z}                                  │ ${6|entier       ,chaîne       ,réel         ,booléen      ,caractère    ,fonction     ,procédure    ,fichier texte|}            │",
            "└────────────────────────────────────┴──────────────────────────┘",
            ""
        ],
        "description": "tableau de déclaration des objets (3 lignes)"
    },
    "nouveau type: tableau": {
        "prefix": ["tdnt-1"],
        "body": [
            "┌───────────────────────────────────────────────────────────────┐",
            "│                        Nouveaux Types                         │",
            "├───────────────────────────────────────────────────────────────┤",
            "│ ${1:tab} = tableau de ${2:20} ${3|entier   ,chaîne   ,réel     ,booléen  ,caractère|}                                 │",
            "└───────────────────────────────────────────────────────────────┘",
            ""
        ],
        "description": "déclaration des nouveaux types"
    },
    "nouveaux types: 2en1": {
        "prefix": ["tdnt-2"],
        "body": [
            "┌───────────────────────────────────────────────────────────────┐",
            "│                        Nouveaux Types                         │",
            "├───────────────────────────────────────────────────────────────┤",
            "│ ${1:eleve} = enregistrement                                        │",
            "│     ${2:nom} : ${3|chaîne   ,entier   ,réel     ,booléen  ,caractère|}                                           │",
            "│     ${4:age} : ${5|entier   ,chaîne   ,réel     ,booléen  ,caractère|}                                           │",
            "│ fin                                                           │",
            "├───────────────────────────────────────────────────────────────┤",
            "│ ${6:tab} = tableau de ${7:20} ${8|entier   ,chaîne   ,réel     ,booléen  ,caractère|}                                 │",
            "└───────────────────────────────────────────────────────────────┘",
            ""
        ],
        "description": "nouveaux types: enregistrement + tableau"
    },
    "boucle pour": {
        "prefix": "pour",
        "body": ["pour ${1:i} de ${2:0} à ${3:N-1} faire", "\t$0", "fin_pour"],
        "description": [
            "Boucle pour (for-loop).",
            "Structure itérative utilisée lorsque le nombre de répétitions est connu à l'avance.",
            "La variable de contrôle parcourt une plage définie (DEBUT → FIN).",
            "Syntaxe de base : pour i de DEBUT à FIN faire ... fin_pour",
            "",
            "Optionnel : un pas personnalisé peut être spécifié (valeur par défaut = 1).",
            "  - Syntaxe complète : pour i de DEBUT à FIN (pas = x) faire ...",
            "  - Règle de validité : si pas > 0, alors DEBUT ≤ FIN ; si pas < 0, alors DEBUT ≥ FIN.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemples :",
            "  pour i de 1 à 10 (pas = 2) faire",
            "    écrire(i)",
            "  fin_pour",
            "  → Affiche : 1 3 5 7 9",
            "",
            "  pour i de 10 à 1 (pas = -2) faire",
            "    écrire(i)",
            "  fin_pour",
            "  → Affiche : 10 8 6 4 2",
            "",
            "  pour i de 5 à 2 (pas = 1) faire",
            "    écrire(i)",
            "  fin_pour",
            "  → Aucune itération (pas > 0 mais DEBUT > FIN)."
        ]
    },
    "si...alors": {
        "prefix": "si-alors",
        "body": ["si ${1:condition} alors", "\t$0", "fin_si"],
        "description": [
            "Structure conditionnelle simple (if).",
            "Permet d'exécuter un bloc d'instructions uniquement si l'expression booléenne est vraie.",
            "Syntaxe : si <booléen> alors ... fin_si",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 (expression vraie) :",
            "  age <-- 25",
            "  si age ≥ 18 alors",
            "    écrire(\"Majeur\")",
            "  fin_si",
            "  → Affiche : Majeur",
            "",
            "Exemple 2 (expression fausse) :",
            "  age <-- 15",
            "  si age ≥ 18 alors",
            "    écrire(\"Majeur\")",
            "  fin_si",
            "  → Aucune sortie",
            "",
            "Note : L'expression (ici « condition ») doit être de type booléen",
            "(résultat d'une comparaison, variable booléenne, etc.)"
        ]
    },
    "si...alors...sinon": {
        "prefix": "si-sinon",
        "body": ["si ${1:condition} alors", "\t$0", "sinon", "\t", "fin_si"],
        "description": [
            "Structure conditionnelle complète (if-else).",
            "Exécute le bloc 'alors' si l'expression booléenne, sinon le bloc 'sinon'.",
            "Syntaxe : si <booléen> alors ... sinon ... fin_si",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 (expression vraie) :",
            "  temp <-- 5",
            "  si temp > 0 alors",
            "    écrire(\"Chaud\")",
            "  sinon",
            "    écrire(\"Froid\")",
            "  fin_si",
            "  → Affiche : Chaud",
            "",
            "Exemple 2 (expression fausse) :",
            "  temp <-- -5",
            "  si temp > 0 alors",
            "    écrire(\"Chaud\")",
            "  sinon",
            "    écrire(\"Froid\")",
            "  fin_si",
            "  → Affiche : Froid"
        ]
    },
    "structure selon": {
        "prefix": "selon",
        "body": [
            "selon ${1:sélecteur}",
            "\t${2:2, 4, 6} : ${3:traitement_1}",
            "\t${4:7..10} : ${5:traitement_2}",
            "\tsinon ${6:traitement_3}",
            "fin_selon",
            "$0"
        ],
        "description": [
            "Structure à choix multiple (switch).",
            "Permet d'exécuter un bloc d'instructions parmi plusieurs, selon la valeur du sélecteur.",
            "Le sélecteur: une variable qui doit être de type ordinal : entier ou caractère.",
            "Les cas peuvent être :",
            "  - une valeur unique (ex. : 1),",
            "  - une liste de valeurs (ex. : 2, 4, 6),",
            "  - un intervalle (ex. : 7..10).",
            "Le bloc 'sinon' est optionnel et s'exécute si aucune correspondance n'est trouvée.",
            "~~~~~~~~~~~~~~",
            "Exemple 1 (Caractère) :",
            "  selon c",
            "    \"A\"..\"Z\" : écrire(\"Lettre majuscule\")",
            "    \"a\"..\"z\" : écrire(\"Lettre minuscule\")",
            "    \"0\"..\"9\" : écrire(\"Chiffre\")",
            "    \"!\", \"?\", \".\" : écrire(\"Ponctuation\")",
            "    sinon écrire(\"Autre caractère\")",
            "  fin_selon",
            "",
            "Exemple 2 (Entier) :",
            "  selon jour",
            "    1..5 : écrire(\"Jour de travail\")",
            "    6..7 : écrire(\"Week-end\")",
            "    sinon écrire(\"Jour invalide\")",
            "  fin_selon"
        ]
    },
    "boucle tant-que": {
        "prefix": "tant-que",
        "body": ["tant que ${1:condition} faire", "\t$0", "fin_tant_que"],
        "description": [
            "Structure itérative à condition d'entrée (while-loop).",
            "Répète un bloc d'instructions tant que l'expression booléenne est vraie.",
            "La condition est testée AVANT chaque itération. La boucle peut ne jamais s'exécuter.",
            "Syntaxe : tant que <booléen> faire ... fin_tant_que",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 (compteur) :",
            "  i <-- 1",
            "  tant que i ≤ 3 faire",
            "    écrire(i)",
            "    i <-- i + 1",
            "  fin_tant_que",
            "  → Affiche : 1 2 3",
            "",
            "Exemple 2 (saisie contrôlée) :",
            "  note <-- -1",
            "  tant que note < 0 ou note > 20 faire",
            "    écrire(\"Entrez une note valide (0-20) : \")",
            "    lire(note)",
            "  fin_tant_que",
            "  → Demande une note jusqu'à ce qu'elle soit valide",
            "",
            "Exemple 3 (boucle jamais exécutée) :",
            "  n <-- 10",
            "  tant que n < 0 faire",
            "    écrire(\"Négatif\")",
            "  fin_tant_que",
            "  → Aucune sortie (condition fausse dès le départ)."
        ]
    },
    "boucle répéter": {
        "prefix": ["répéter", "repeter"],
        "body": ["répéter", "\t$0", "jusqu'à ${1:condition}"],
        "description": [
            "Structure itérative à condition d'arrêt (repeat-until loop).",
            "Répète un bloc d'instructions jusqu'à ce que l'expression booléenne spécifiée devienne vraie.",
            "La condition est testée APRÈS la première itération. La boucle s'exécute au moins une fois.",
            "Syntaxe : répéter ... jusqu'à <booléen>",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 (compteur) :",
            "  i <-- 1",
            "  répéter",
            "    écrire(i)",
            "    i <-- i + 1",
            "  jusqu'à i > 3",
            "  → Affiche : 1 2 3",
            "",
            "Exemple 2 (saisie contrôlée) :",
            "  répéter",
            "    écrire(\"Entrez un nombre positif : \")",
            "    lire(nombre)",
            "  jusqu'à nombre ≥ 0",
            "  → Demande un nombre jusqu'à ce qu'il soit positif",
            "",
            "Exemple 3 (exécution garantie) :",
            "  x <-- 10",
            "  répéter",
            "    écrire(\"Exécuté au moins une fois\")",
            "  jusqu'à x > 5",
            "  → Affiche : \"Exécuté au moins une fois\"",
            "  → Bien que la condition (x > 5) soit vraie dès le départ,",
            "    le corps de la boucle s'exécute toujours une fois, puis la condition est évaluée."
        ]
    },
    "de": {
        "prefix": "de",
        "body": ["de $0"]
    },
    "début": {
        "prefix": ["début", "debut"],
        "body": ["début $0"]
    },
    "faire": {
        "prefix": "faire",
        "body": ["faire $0"]
    },
    "fin": {
        "prefix": "fin",
        "body": ["fin $0"]
    },
    "fin_pour": {
        "prefix": "fin_pour",
        "body": ["fin_pour $0"]
    },
    "fin_si": {
        "prefix": "fin_si",
        "body": ["fin_si $0"]
    },
    "fin_selon": {
        "prefix": "fin_selon",
        "body": ["fin_selon $0"]
    },
    "fin_tant_que": {
        "prefix": "fin_tant_que",
        "body": ["fin_tant_que $0"]
    },
    "jusqu'à": {
        "prefix": "jusqu'à",
        "body": ["jusqu'à $0"]
    },
    "pas": {
        "prefix": "pas",
        "body": ["pas $0"]
    },
    "retourner": {
        "prefix": "retourner",
        "body": ["retourner $0"],
        "description": [
            "instruction : retourner expression",
            "Termine l'exécution d'une fonction et renvoie la valeur de l'expression.",
            "",
            "Règles :",
            "  - La valeur retournée doit être de type simple :",
            "    entier, réel, booléen, caractère ou chaîne.",
            "  - Une seule instruction retourner peut être exécutée.",
            "    Si plusieurs sont présentes, elles doivent se trouver dans des chemins",
            "    mutuellement exclusifs (ex. : si...sinon).",
            "",
            "Note : réservée aux fonctions, pas aux procédures.",
            "",
            "Exemple 1 : utilisation correcte",
            "  fonction exemple_fn(x: entier) : entier",
            "  début",
            "    si x > 0 alors",
            "      retourner 10",
            "    sinon",
            "      retourner 20",
            "    fin_si",
            "  fin",
            "  → ✅ Retourne 10 si x > 0, sinon 20",
            "",
            "Exemple 2 : utilisation incorrecte",
            "  fonction exemple_fn(x: entier) : entier",
            "  début",
            "    si x > 0 alors",
            "      retourner 10",
            "    fin_si",
            "    retourner 20",
            "  fin",
            "  → ❌ Erreur : deux instructions retourner peuvent être exécutées",
            "",
            "Exemple 3 : alternative recommandée (retour unique)",
            "  fonction exemple_fn(x: entier) : entier",
            "  début",
            "    résultat <-- 20",
            "    si x > 0 alors",
            "      résultat <-- 10",
            "    fin_si",
            "    retourner résultat",
            "  fin",
            "  → ✅ Un seul point de retour, plus facile à déboguer"
        ]
    },
    "selon": {
        "prefix": "selon",
        "body": ["selon $0"]
    },
    "sinon": {
        "prefix": "sinon",
        "body": ["sinon $0"]
    },
    "fonction aléa()": {
        "prefix": ["aléa", "alea"],
        "body": ["aléa(${1:vi}, ${2:vf}) $0"],
        "description": [
            "fonction aléa(vi: entier, vf: entier): entier",
            "",
            "Génère un entier aléatoire compris entre vi et vf (bornes incluses).",
            "Contrainte: vi ≤ vf.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 : Lancer de dé",
            "  x <-- aléa(1, 6)",
            "  → x ∈ {1, 2, 3, 4, 5, 6}",
            "",
            "Exemple 2 : Lettre majuscule aléatoire",
            "  code_ascii <-- aléa(65, 90)",
            "  lettre <-- chr(code_ascii)",
            "  → contient un caractère entre \"A\" et \"Z\""
        ]
    },
    "fonction arrondi()": {
        "prefix": "arrondi",
        "body": ["arrondi(${1:x}) $0"],
        "description": [
            "fonction arrondi(x: réel): entier",
            "",
            "Retourne l'entier le plus proche du nombre réel donné.",
            "Règle : Si la décimale est .5, on arrondit toujours à l'entier supérieur.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 (Décimale < .5) :",
            "  x <-- arrondi(12.3)",
            "  → x vaut 12",
            "",
            "Exemple 2 (Décimale > .5) :",
            "  x <-- arrondi(12.7)",
            "  → x vaut 13",
            "",
            "Exemple 3 (Règle du .5) :",
            "  x <-- arrondi(12.5)",
            "  → x vaut 13 (Arrondi au supérieur)"
        ]
    },
    "fonction chr()": {
        "prefix": "chr",
        "body": ["chr(${1:code_ascii}) $0"],
        "description": [
            "fonction chr(code_ascii: entier): caractère",
            "",
            "Retourne le caractère correspondant au code ASCII (ou Unicode) donné.",
            "Contrainte : Le code doit être un entier positif (entre 0 et 255 pour ASCII étendu).",
            "Fonction inverse de ord().",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 : Lettre majuscule",
            "  c <-- chr(65)",
            "  → c vaut \"A\"",
            "",
            "Exemple 2 : Lettre minuscule",
            "  c <-- chr(97)",
            "  → c vaut \"A\"",
            "",
            "Exemple 3 : Chiffre",
            "  c <-- chr(48)",
            "  → c vaut \"0\""
        ]
    },
    "fonction convch()": {
        "prefix": "convch",
        "body": ["convch(${1:x}) $0"],
        "description": [
            "fonction convch(x: réel | entier): chaîne",
            "",
            "Convertit un nombre (entier ou réel) en une chaîne de caractères.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 (entier) :",
            "  ch <-- convch(42)",
            "  → ch vaut \"42\"",
            "",
            "Exemple 2 (réel) :",
            "  ch <-- convch(3.14)",
            "  → ch vaut \"3.14\"",
            "",
            "Exemple 3 (affichage formaté) :",
            "  age <-- 17",
            "  message <-- \"J'ai \" + convch(age) + \" ans.\"",
            "  → message vaut \"J'ai 17 ans.\""
        ]
    },
    "fonction effacer()": {
        "prefix": "effacer",
        "body": ["effacer(${1:ch}, ${2:d}, ${3:f}) $0"],
        "description": [
            "fonction effacer(ch: chaîne, d: entier, f: entier): chaîne",
            "",
            "Retourne une copie de la chaîne ch après suppression des caractères",
            "situés entre les positions d et f (d incluse, f exclue).",
            "Contrainte : 0 ≤ d < f ≤ long(ch)",
            "Note : L'indexation commence à 0 (premier caractère = indice 0).",
            "",
            "~~~~~~~~~~~~~~",
            "// ch = \"B o n j o u r\"",
            "//       0 1 2 3 4 5 6 ",
            "",
            "Exemple 1 :",
            "  ch_res <-- effacer(ch, 1, 4)",
            "  → ch_res vaut \"Bour\", ch reste inchangée (=\"Bonjour\")",
            "",
            "Exemple 2 (suppression à la fin):",
            "  ch_res  <-- effacer(ch, 3, long(ch))",
            "  → ch_res vaut \"Bon\""
        ]
    },
    "fonction ent()": {
        "prefix": "ent",
        "body": ["ent(${1:x}) $0"],
        "description": [
            "fonction ent(x: réel): entier",
            "",
            "Retourne la partie entière du nombre réel x.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 (Positif) :",
            "  x <-- ent(12.75)",
            "  → x vaut 12",
            "",
            "Exemple 2 (Négatif) :",
            "  x <-- ent(-12.75)",
            "  → x vaut -12 (Troncature vers zéro)"
        ]
    },
    "fonction estnum()": {
        "prefix": "estnum",
        "body": ["estnum(${1:ch}) $0"],
        "description": [
            "fonction estnum(ch: chaîne): booléen",
            "",
            "Retourne vrai si la chaîne ch peut être convertie en nombre (entier ou réel),",
            "faux sinon.Utile avant d'utiliser la fonction valeur(ch) pour éviter les erreurs.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 (vrai) :",
            "  estnum(\"123\")    → vrai (entier)",
            "  estnum(\"-3.14\")  → vrai (réel négatif)",
            "  estnum(\"1.5e-3\") → vrai (notation scientifique)",
            "",
            "Exemple 2 (faux) :",
            "  estnum(\"47abc\")  → faux (contient des caractères non valides)",
            "  estnum(\"12.3.5\") → faux (format numérique invalide)",
            "  estnum(\"2 + 3\")  → faux (n'est pas une simple valeur numérique)"
        ]
    },
    "procédure fermer()": {
        "prefix": "fermer",
        "body": ["fermer(${1:f}) $0"],
        "description": [
            "procédure fermer(@f: fichier)",
            "",
            "Ferme le fichier associé à la variable f et libère les ressources système.",
            "Après fermeture, la variable f n'est plus liée au fichier physique.",
            "Il est recommandé de toujours fermer un fichier après utilisation.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple :",
            "  ouvrir(\"data.txt\", f, \"w\")",
            "  // ... écriture dans le fichier ...",
            "  fermer(f)"
        ]
    },
    "fonction fin_fichier()": {
        "prefix": "fin_fichier",
        "body": ["fin_fichier(${1:f}) $0"],
        "description": [
            "fonction fin_fichier(@f: fichier): booléen",
            "",
            "Retourne vrai si le pointeur de lecture est à la fin du fichier f, faux sinon.",
            "Contrainte : f doit être ouvert en mode lecture (\"r\" ou \"rb\").",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple : Affichage du contenu d'un fichier texte",
            "  ouvrir(\"noms.txt\", f, \"r\")",
            "  si non fin_fichier(f) alors",
            "    lire(f, ch)",
            "    écrire(ch)",
            "  fin_si",
            "  fermer(f)"
        ]
    },

    "procédure lire()": {
        "prefix": "lire",
        "body": ["lire(${1:var}) $0"],
        "description": [
            "procédure lire(@var: entier | réel | caractère | chaîne)",
            "procédure lire(@f: fichier texte, @var: chaîne)",
            "procédure lire(@f: fichier de <type>, @var: <type>)",
            "",
            "Permet de récupérer des données depuis le clavier ou un fichier.",
            "La syntaxe dépend de la source :",
            "",
            "1. Saisie Clavier :",
            "  - Syntaxe : lire(var)",
            "  - var doit être de type entier, réel, caractère ou chaîne",
            "  - Lit une seule valeur depuis le clavier",
            "  - Exemple : lire(age) → demande à l'utilisateur de saisir l'âge.",
            "",
            "2. Lecture fichier texte (mode \"r\") :",
            "  - Syntaxe : lire(f, ch)",
            "  - Lit tout le contenu restant (depuis le pointeur courant)",
            "  - Exemple : lire(f, contenu)",
            "",
            "3. Lecture fichier binaire (mode \"rb\") :",
            "  - Syntaxe : lire(f, e)",
            "  - Lit un seul élément, et avance le pointeur",
            "  - Exemple : si f: fichier de entier → lire(f, e) lit un entier",
            "",
            "~~~~~~~~~~~~~~",
            "Exemples d'usage :",
            "// 1. Clavier",
            "  lire(nom)",
            "",
            "// 2. Fichier texte",
            "  ouvrir(\"texte.txt\", f, \"r\")",
            "  lire(f, ch)",
            "  fermer(f)",
            "",
            "// 3. Fichier binaire",
            "  ouvrir(\"nombres.dat\", f, \"rb\")",
            "  lire(f, x)",
            "  fermer(f)"
        ]
    },
    "procédure lire_ligne()": {
        "prefix": "lire_ligne",
        "body": ["lire_ligne(${1:f}, ${2:ch}) $0"],
        "description": [
            "procédure lire_ligne(@f: fichier texte, @ch: chaîne)",
            "",
            "Lit une ligne complète depuis le fichier texte f et la stocke dans ch.",
            "Après la lecture, le pointeur du fichier avance au début de la ligne suivante",
            "ou à la fin du fichier si aucune ligne ne reste",
            "Le caractère de fin de ligne (retour à la ligne) n'est pas inclus dans ch",
            "Contrainte : f doit être ouvert en mode lecture (\"r\").",
            "⚠️ Ne s'applique qu'aux fichiers texte.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple : Lecture ligne par ligne d'un fichier",
            "  ouvrir(\"data.txt\", f, \"r\")",
            "  tant que non fin_fichier(f) faire",
            "    lire_ligne(f, ligne)",
            "    écrire_nl(\"Ligne lue : \", ligne)",
            "  fin_tant_que",
            "  fermer(f)"
        ]
    },
    "fonction long()": {
        "prefix": "long",
        "body": ["long(${1:ch}) $0"],
        "description": [
            "fonction long(ch: chaîne): entier",
            "",
            "Retourne le nombre de caractères de ch.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 :",
            "  n <-- long(\"Algo\")",
            "  → n vaut 4",
            "",
            "Exemple 2 :",
            "  n <-- long(\"\")",
            "  → n vaut 0",
            "",
            "Exemple 3 :",
            "  n <-- long(\"123 ABC!\")",
            "  → n vaut 8 (les espaces et symboles sont comptés)"
        ]
    },
    "fonction majus()": {
        "prefix": "majus",
        "body": ["majus(${1:cc}) $0"],
        "description": [
            "fonction majus(cc: chaîne | caractère): chaîne | caractère",
            "",
            "Convertit tous les caractères alphabétiques de cc en majuscules.",
            "Les caractères non-alphabétiques restent inchangés.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 : chaîne",
            "  ch <-- majus(\"1. Algo /!\\\")",
            "  → ch vaut \"1. ALGO /!\\\"",
            "",
            "Exemple 2 : caractère",
            "  c <-- majus(\"a\")",
            "  → c vaut \"A\""
        ]
    },
    "fonction ord()": {
        "prefix": "ord",
        "body": ["ord(${1:c}) $0"],
        "description": [
            "fonction ord(c: caractère): entier",
            "",
            "Retourne le code ASCII (ou Unicode) du caractère c.",
            "Fonction inverse de chr().",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 : Lettre majuscule",
            "  n <-- ord(\"A\")",
            "  → n = 65",
            "",
            "Exemple 2 : Lettre minuscule",
            "  n <-- ord(\"a\")",
            "  → n = 97",
            "",
            "Exemple 3 : Chiffre",
            "  n <-- ord(\"0\")",
            "  → n = 48",
            "",
            "Exemple 4 : Caractère spécial",
            "  n <-- ord(\"#\")",
            "  → n = 35"
        ]
    },
    "procédure ouvrir()": {
        "prefix": "ouvrir",
        "body": ["ouvrir(${1:chemin}, ${2:f}, \"${3:r}\") $0"],
        "description": [
            "procédure ouvrir(chemin: chaîne, @f: fichier, mode: chaîne)",
            "",
            "Ouvre un fichier à l'emplacement chemin et l'associe à la variable f.",
            "Le mode d'ouverture détermine le type d'accès :",
            "",
            "  • \"r\"  : lecture (fichier texte)",
            "    \"rb\" : lecture (fichier binaire)",
            "",
            "  • \"w\"  : écriture (crée ou écrase le fichier texte)",
            "    \"wb\" : écriture (crée ou écrase le fichier binaire)",
            "",
            "  • \"a\"  : ajout à la fin du fichier texte",
            "    \"ab\" : ajout à la fin du fichier binaire",
            "",
            "Le suffixe \"b\" indique que le fichier est traité en mode binaire.",
            "",
            "Note : Le chemin peut être relatif ou absolu:",
            "  - relatif (recommandé pour la portabilité) : ",
            "    Le chemin est défini par rapport à l'emplacement du programme.",
            "    exemple → \"data.txt\" ou \"docs\\data.txt\"",
            "  - absolu : Le chemin est complet depuis la racine du système.",
            "    exemple → \"C:\\Users\\MonNom\\Desktop\\log.txt\"",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 (lecture texte) :",
            "  ouvrir(\"notes.txt\", f, \"r\")",
            "",
            "Exemple 2 (écriture binaire) :",
            "  ouvrir(\"archive.dat\", f, \"wb\")"
        ]
    },
    "fonction pos()": {
        "prefix": "pos",
        "body": ["pos(${1:sous_ch}, ${2:ch}) $0"],
        "description": [
            "fonction pos(sous_ch: chaîne, ch: chaîne): entier",
            "",
            "Retourne la position de la première occurrence de sous_ch dans ch.",
            "Si sous_ch n'est pas trouvée, retourne -1.",
            "Note : L'indexation commence à 0 (premier caractère = indice 0).",
            "",
            "~~~~~~~~~~~~~~",
            "// ch = \"B o n j o u r\"",
            "//       0 1 2 3 4 5 6 ",
            "",
            "Exemple 1 :",
            "  p <-- pos(\"o\", ch)",
            "  → p vaut 1",
            "",
            "Exemple 2 :",
            "  p <-- pos(\"jour\", ch)",
            "  → p vaut 3",
            "",
            "Exemple 3 (non trouvé) :",
            "  p <-- pos(\"xyz\", ch)",
            "  → p vaut -1"
        ]
    },
    "fonction racine_carrée()": {
        "prefix": "racine_carrée",
        "body": ["racine_carrée(${1:x}) $0"],
        "description": [
            "fonction racine_carrée(x: réel): réel",
            "",
            "Retourne la racine carrée du nombre x.",
            "Contrainte : x doit être positif ou nul (x ≥ 0).",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 :",
            "  r <-- racine_carrée(25)",
            "  → r vaut 5.0",
            "",
            "Exemple 2 :",
            "  r <-- racine_carrée(2)",
            "  → r vaut environ 1.414"
        ]
    },
    "fonction sous_chaîne()": {
        "prefix": "sous_chaîne",
        "body": ["sous_chaîne(${1:ch}, ${2:d}, ${3:f}) $0"],
        "description": [
            "fonction sous_chaîne(ch: chaîne, d: entier, f: entier): chaîne",
            "",
            "Retourne une nouvelle chaîne contenant les caractères de ch",
            "situés entre les positions d et f (d incluse, f exclue).",
            "Contrainte : 0 ≤ d < f ≤ long(ch)",
            "Note : L'indexation commence à 0 (premier caractère = indice 0).",
            "",
            "~~~~~~~~~~~~~~",
            "// ch = \"B o n j o u r\"",
            "//       0 1 2 3 4 5 6",
            "",
            "Exemple 1 (extraction du début) :",
            "  ch_res <-- sous_chaîne(ch, 0, 3)",
            "  → ch_res vaut \"Bon\", ch reste inchangée (=\"Bonjour\")",
            "",
            "Exemple 2 :",
            "  ch_res <-- sous_chaîne(ch, 3, long(ch))",
            "  → ch_res vaut \"jour\"",
            "",
            "Exemple 3 (extraction d'un seul caractère) :",
            "  ch_res <-- sous_chaîne(ch, 2, 3)",
            "  → ch_res vaut \"n\""
        ]
    },
    "fonction valeur()": {
        "prefix": "valeur",
        "body": ["valeur(${1:ch}) $0"],
        "description": [
            "fonction valeur(ch: chaîne): entier | réel",
            "",
            "Convertit la chaîne ch en valeur numérique (entier ou réel).",
            "Contrainte : la chaîne doit représenter un nombre valide.",
            "Recommandation : utiliser estnum(ch) pour vérifier avant conversion.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 : entier",
            "  n <-- valeur(\"42\")",
            "  → n vaut 42",
            "",
            "Exemple 2 : réel",
            "  x <-- valeur(\"3.14\")",
            "  → x vaut 3.14",
            "",
            "Exemple 3 : notation scientifique",
            "  x <-- valeur(\"1.5e-2\")",
            "  → x vaut 0.015",
            "",
            "Exemple 4 : vérification avec estnum()",
            "  si estnum(ch) alors",
            "    n <-- valeur(ch)",
            "  sinon",
            "    écrire(\"Erreur : ch n'est pas un nombre valide\")",
            "  fin_si"
        ]
    },
    "procédure écrire()": {
        "prefix": ["écrire", "ecrire"],
        "body": ["écrire(${1:expression}) $0"],
        "description": [
            "procédure écrire(exp_1 [, exp_2, ...])",
            "procédure écrire(@f: fichier texte, exp: chaîne)",
            "procédure écrire(@f: fichier de <type>, exp: <type>)",
            "",
            "Permet d'afficher des valeurs à l'écran ou de les écrire dans un fichier.",
            "La syntaxe dépend du nombre et du type des paramètres :",
            "",
            "1. Affichage à l'écran (sortie standard) :",
            "   - Syntaxe : écrire(exp1 [, exp2, ...])",
            "   - Chaque expression doit être de type simple :",
            "     entier, réel, caractère, chaîne ou booléen.",
            "   - Les valeurs sont affichées sans saut de ligne (concaténées).",
            "   - Exemple : écrire(\"Résultat = \", x) → affiche « Résultat = 42 ».",
            "",
            "2. Écriture dans un fichier texte (mode \"w\" ou \"a\") :",
            "   - Syntaxe : écrire(f, ch)",
            "   - Écrit la chaîne ch à la position courante du fichier texte f.",
            "   - Aucun retour à la ligne automatique.",
            "   - Exemple : écrire(f, \"Bonjour\")",
            "",
            "3. Écriture dans un fichier binaire (mode \"wb\" ou \"ab\") :",
            "  - Syntaxe : écrire(f, e)",
            "  - Écrit un seul élément e dans le fichier binaire f.",
            "  - Contrainte : Le type de e doit correspondre au type des éléments de f.",
            "  - Exemple : écrire(f, 42)  // f : fichier de entier",
            "",
            "~~~~~~~~~~~~~~",
            "Exemples d'usage :",
            "// 1. Écran",
            "  écrire(\"Nom : \", nom, \", Âge : \", age)",
            "  → affiche « Nom : Ali, Âge : 16 »",
            "",
            "// 2. Fichier texte",
            "  ouvrir(\"log.txt\", f, \"a\")",
            "  écrire(f, \"[INFO] Traitement terminé\")",
            "  fermer(f)",
            "",
            "// 3. Fichier binaire",
            "  ouvrir(\"scores.dat\", f, \"wb\")",
            "  écrire(f, score)  // score est un entier",
            "  fermer(f)"
        ]
    },
    "procédure écrire_nl()": {
        "prefix": ["écrire_nl", "ecrire_nl"],
        "body": ["écrire_nl(${1:expression}) $0"],
        "description": [
            "procédure écrire_nl(exp_1 [, exp_2, ...])",
            "procédure écrire_nl(@f: fichier texte, ch: chaîne)",
            "",
            "Identique à la procédure 'écrire', mais ajoute un retour à la ligne :",
            "la prochaine écriture se fera sur une nouvelle ligne",
            "",
            "⚠️ Ne s'applique pas aux fichiers binaires.",
            "",
            "1. Affichage à l'écran avec saut de ligne :",
            "   - Syntaxe : écrire_nl(exp1 [, exp2, ...])",
            "   - Affiche les valeurs puis passe à la ligne suivante.",
            "   - Exemple : écrire_nl(\"Résultat = \", x)",
            "     → affiche « Résultat = 42 » puis saute une ligne.",
            "",
            "2. Écriture dans un fichier texte avec saut de ligne :",
            "   - Syntaxe : écrire_nl(f, ch)",
            "   - Écrit la chaîne ch suivie d'un retour à la ligne dans le fichier f.",
            "   - Exemple : écrire_nl(f, \"Ligne de texte\")",
            "     → écrit \"Ligne de texte\" puis passe à la ligne suivante.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemples d'usage :",
            "// 1. Écran avec sauts de ligne",
            "  écrire_nl(\"=== Début du programme ===\")",
            "  écrire_nl(\"Résultat :\", calcul)",
            "  écrire_nl(\"=== Fin ===\")",
            "  → affiche 3 lignes distinctes",
            "",
            "// 2. Fichier texte avec lignes séparées",
            "  ouvrir(\"rapport.txt\", f, \"w\")",
            "  écrire_nl(f, \"Titre du rapport\")",
            "  écrire_nl(f, \"===============\")",
            "  écrire_nl(f, \"Contenu...\")",
            "  fermer(f)",
            "  → crée un fichier avec 3 lignes distinctes"
        ]
    },
    "type booléen": {
        "prefix": ["booléen"],
        "body": ["booléen$0"],
        "description": [
            "type booléen",
            "",
            "Type simple et ordinal représentant une valeur logique.",
            "",
            "Propriétés :",
            "  - Valeurs : vrai, faux",
            "  - Ordre : faux < vrai",
            "  - Appartenance : peut être utilisé avec l'opérateur ∈",
            "    (ex. : b ∈ {vrai, faux})",
            "",
            "Opérateurs :",
            "  - Logiques : et, ou, non",
            "  - Comparaison : =, ≠, <, >, ≤, ≥",
            "",
            "Rôle principal :",
            "  - Stocker le résultat d'une comparaison (ex. : âge ≥ 18).",
            "  - Contrôler le flux d'exécution (structures si, tant que, etc.).",
            "  - Résultat des fonctions de test (ex. : estnum(ch))."
        ]
    },
    "type caractère": {
        "prefix": ["caractère"],
        "body": ["caractère$0"],
        "description": [
            "type caractère",
            "",
            "Type simple et ordinal représentant une unité unique non vide",
            "(lettre, chiffre, signe de ponctuation, espace, symbole...).",
            "",
            "Propriétés :",
            "  - Valeurs : un seul symbole entre guillemets doubles (ex. : \"A\", \"1\", \"@\", \" \")",
            "  - Ordre : selon la table ASCII (ex. : \"0\" < \"9\" < \"A\" < \"Z\" < \"a\" < \"z\")",
            "  - Appartenance : peut être utilisé avec l'opérateur ∈",
            "    (ex. : c ∈ [\"A\"..\"Z\"] ou c ∈ {\"a\", \"e\", \"i\", \"o\", \"u\"})",
            "",
            "Opérateurs :",
            "  - Comparaison : =, ≠, <, >, ≤, ≥",
            "  - Concaténation : + (avec chaînes ou caractères) → renvoie une chaîne",
            "    (ex. : \"a\" + \"b\" → \"ab\",  \"X\" + \"123\" → \"X123\")",
            "",
            "Fonctions principales :",
            "  - chr(n) : convertit un code ASCII en caractère",
            "  - ord(c) : convertit un caractère en code ASCII"
        ]
    },
    "type chaîne": {
        "prefix": ["chaîne", "chaine"],
        "body": ["chaîne$0"],
        "description": [
            "type chaîne",
            "",
            "Type simple représentant une séquence de caractères.",
            "Une chaîne peut être vide (\"\"), contrairement au caractère.",
            "",
            "Propriétés :",
            "  - Valeurs : texte entre guillemets doubles (ex. : \"Bonjour\", \"\", \"123\")",
            "  - Taille : de 0 à n caractères (fonction long(ch))",
            "  - Accès : Ch[i] avec 0 ≤ i < long(Ch) (indexation à partir de 0)",
            "",
            "Opérateurs :",
            "  - Concaténation : + (chaînes ou caractères) → chaîne",
            "    (ex. : \"Bon\" + \"jour\" → \"Bonjour\")",
            "  - Comparaison : =, ≠, <, ≤, >, ≥ (ordre lexicographique ASCII)",
            "    (ex. : \"Alia\" < \"ali\")",
            "",
            "Fonctions principales :",
            "  - long(ch) : longueur de la chaîne",
            "  - estnum(ch) : teste si convertible en nombre",
            "  - valeur(ch) : conversion chaîne → nombre",
            "  - convch(n) : conversion nombre → chaîne",
            "  - majus(ch) : conversion en majuscules",
            "  - pos(sch, ch) : position d'une sous-chaîne",
            "  - sous_chaîne(ch, d, f) : extraction",
            "  - effacer(ch, d, f) : suppression"
        ]
    },
    "type enregistrement": {
        "prefix": "enregistrement",
        "body": ["enregistrement$0"],
        "description": [
            "type enregistrement",
            "",
            "Type composé permettant de regrouper plusieurs champs",
            "sous un même nom, généralement de types variés.",
            "",
            "Propriétés :",
            "  - Champs : types simples, tableaux ou autres enregistrements (imbrication).",
            "  - Accès : notation par point (ex. : variable.champ).",
            "",
            "Usage principal :",
            "  - Regrouper et simplifier la gestion de données liées",
            "    (ex. : informations d'un élève, coordonnées 2D).",
            "",
            "Exemple 1 : Déclaration directe d'une variable :",
            "┌──────────────┬──────────────────────────┐",
            "│     Objet    │      Nature / Type       │",
            "├──────────────┼──────────────────────────┤",
            "│ e            │ enregistrement           │",
            "│              │   nom, tel : chaîne      │",
            "│              │   age : entier           │",
            "│              │ fin                      │",
            "└──────────────┴──────────────────────────┘",
            "",
            "Exemple 2 : Déclaration et utilisation d'un nouveau type nommé :",
            "┌─────────────────────────────────────────┐",
            "│            Nouveaux Types               │",
            "├─────────────────────────────────────────┤",
            "│ eleve = enregistrement                  │",
            "│     nom, tel : chaîne                   │",
            "│     age : entier                        │",
            "│ fin                                     │",
            "└─────────────────────────────────────────┘",
            "",
            "Déclaration de la variable e avec le nouveau type eleve :",
            "┌──────────────┬──────────────────────────┐",
            "│     Objet    │      Nature / Type       │",
            "├──────────────┼──────────────────────────┤",
            "│ e            │ eleve                    │",
            "└──────────────┴──────────────────────────┘"
        ]
    },
    "type entier": {
        "prefix": "entier",
        "body": ["entier$0"],
        "description": [
            "type entier",
            "",
            "Type simple et ordinal représentant un nombre entier relatif.",
            "",
            "Propriétés :",
            "  - Valeurs : nombres sans partie décimale (ex. : -5, 0, 42, 1000)",
            "  - Ordre : ordre numérique naturel (-3 < 0 < 7)",
            "  - Appartenance : peut être utilisé avec l'opérateur ∈",
            "    (ex. : n ∈ [1..10] ou n ∈ {0, 2, 4, 6, 8})",
            "",
            "Opérateurs :",
            "  - Arithmétiques : +, -, *, / (→ réel), div (division entière), mod (reste)",
            "    (ex. : 7 / 2 → 3.5, 7 div 2 → 3, 7 mod 2 → 1)",
            "  - Comparaison : =, ≠, <, ≤, >, ≥",
            "",
            "Fonctions principales :",
            "  - aléa(vi, vf) : entier aléatoire dans [vi..vf]",
            "  - abs(x) : valeur absolue",
            "  - racine_carrée(x) : racine carrée (→ réel)",
            "  - ent(x) : partie entière d'un réel (→ entier)"
        ]
    },
    "type fichier texte": {
        "prefix": ["text", "fichier-texte"],
        "body": ["fichier texte$0"],
        "description": [
            "type fichier texte",
            "",
            "Type représentant un fichier contenant des données sous forme de texte.",
            "",
            "Propriétés :",
            "  - Contenu : caractères lisibles.",
            "  - Accès : séquentiel.",
            "  - Lisibilité : lisible et éditable par tout éditeur de texte.",
            "",
            "Opérations associées :",
            "  - Procédures : ouvrir, fermer, lire, lire_ligne, écrire, écrire_nl",
            "  - Fonction : fin_fichier",
            "",
            "Usage typique :",
            "  - Fichiers de configuration, logs, documents texte"
        ]
    },
    "type fichier typé": {
        "prefix": ["fichier-typé", "fichier-binaire"],
        "body": ["fichier de ${1:entier}$0"],
        "description": [
            "type fichier typé (binaire)",
            "",
            "Type représentant un fichier binaire contenant des éléments",
            "de même type (simples, tableaux ou enregistrements).",
            "",
            "Propriétés :",
            "  - Contenu : éléments homogènes de types simples ou composés.",
            "  - Accès : séquentiel (lecture/écriture élément par élément).",
            "  - Lisibilité : non lisible directement par un éditeur de texte",
            "    (nécessite un programme pour interpréter les données).",
            "",
            "Opérations associées :",
            "  - Procédures : ouvrir, fermer, lire, écrire",
            "  - Fonction : fin_fichier",
            "",
            "Usage typique :",
            "  - Stockage compact de données structurées (ex. : liste d'élèves, séries numériques)"
        ]
    },
    "type réel": {
        "prefix": ["réel", "reel"],
        "body": ["réel$0"],
        "description": [
            "type réel",
            "",
            "Type simple représentant un nombre à virgule flottante (positif, négatif ou nul).",
            "",
            "Propriétés :",
            "  - Valeurs : nombres avec ou sans partie décimale (ex. : -3.14, 0.0, 42.0, 1.5e-2)",
            "  - Ordre : ordre numérique naturel (-2.5 < 0.0 < 3.14)",
            "  - ⚠️ Pas d'appartenance avec ∈ (les réels ne sont pas ordinaux)",
            "    (utiliser des comparaisons : x ≥ a et x ≤ b)",
            "",
            "Opérateurs :",
            "  - Arithmétiques : +, -, *, / (division réelle)",
            "    (ex. : 7.0 / 2.0 → 3.5, 5.0 * 2.5 → 12.5)",
            "  - Comparaison : =, ≠, <, ≤, >, ≥",
            "",
            "Fonctions principales :",
            "  - abs(x) : valeur absolue",
            "  - racine_carrée(x) : racine carrée",
            "  - arrondi(x) : entier le plus proche (→ entier)",
            "  - ent(x) : partie entière (→ entier)"
        ]
    },
    "type tableau": {
        "prefix": "tableau",
        "body": ["tableau de ${1:20} ${2:entier}$0"]
    },
    "type fonction": {
        "prefix": "fonction",
        "body": ["fonction $0"]
    },
    "type procédure": {
        "prefix": ["procédure", "proc"],
        "body": ["procédure $0"]
    },
    "opérateur ≥": {
        "prefix": [">="],
        "body": ["≥ $0"],
        "description": [
            "opérateur ≥ (supérieur ou égal)",
            "",
            "Syntaxe : expression1 ≥ expression2",
            "Retourne vrai si expression1 est supérieure ou égale à expression2,",
            "faux sinon.",
            "",
            "S'applique uniquement aux types simples : ",
            "  - entier, réel, booléen, caractère et chaîne.",
            "Contrainte : Les deux expressions doivent être de types compatibles",
            "pour la comparaison.",
            "",
            "Types compatibles :",
            "  - entier, réel : comparaison numérique",
            "  - caractère, chaîne : comparaison ASCII/lexicographique",
            "  - booléen : faux < vrai",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 : nombres",
            "  5 ≥ 3     → vrai",
            "  4 ≥ 4.0   → vrai",
            "  2 ≥ 5     → faux",
            "",
            "Exemple 2 : caractères",
            "  \"C\" ≥ \"A\" → vrai  (67 ≥ 65 en ASCII)",
            "  \"a\" ≥ \"A\" → vrai  (97 ≥ 65)",
            "",
            "Exemple 3 : chaînes",
            "  \"Ali\" ≥ \"Ahmed\" → vrai (comparaison lexicographique)",
            "  \"Ali\" ≥ \"Alia\"  → faux",
            "",
            "Exemple 4 : booléens",
            "  vrai ≥ faux → vrai"
        ]
    },
    "opérateur ≤": {
        "prefix": ["<="],
        "body": ["≤ $0"],
        "description": [
            "opérateur ≤ (inférieur ou égal)",
            "",
            "Syntaxe : expression1 ≤ expression2",
            "Retourne vrai si expression1 est inférieure ou égale à expression2,",
            "faux sinon.",
            "",
            "S'applique uniquement aux types simples : ",
            "  - entier, réel, booléen, caractère et chaîne.",
            "Contrainte : Les deux expressions doivent être de types compatibles",
            "pour la comparaison.",
            "",
            "Types compatibles :",
            "  - entier, réel : comparaison numérique",
            "  - caractère, chaîne : comparaison ASCII/lexicographique",
            "  - booléen : faux < vrai",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 : nombres",
            "  3 ≤ 5     → vrai",
            "  4.0 ≤ 4   → vrai",
            "  5 ≤ 2     → faux",
            "",
            "Exemple 2 : caractères",
            "  \"A\" ≤ \"C\" → vrai  (65 ≤ 67 en ASCII)",
            "  \"A\" ≤ \"a\" → vrai  (65 ≤ 97)",
            "",
            "Exemple 3 : chaînes",
            "  \"Ahmed\" ≤ \"Ali\" → vrai (comparaison lexicographique)",
            "  \"Alia\" ≤ \"Ali\"  → faux",
            "",
            "Exemple 4 : booléens",
            "  faux ≤ vrai → vrai"
        ]
    },
    "opérateur ∈": {
        "prefix": ["in", "dans", "appartient"],
        "body": "∈ $0",
        "description": [
            "opérateur ∈ (appartient à / est dans)",
            "",
            "Syntaxe : expression ∈ [intervalle] ou expression ∈ {ensemble}",
            "",
            "Retourne vrai si la valeur appartient à l'ensemble ou à l'intervalle spécifié,",
            "faux sinon.",
            "",
            "S'applique uniquement aux types ordinaux :",
            "  - entier, caractère, booléen.",
            "⚠️ Ne s'applique pas aux réels ni aux chaînes.",
            "",
            "Formes autorisées :",
            "  - Intervalle : [début .. fin]   (bornes incluses)",
            "  - Ensemble : {v1, v2, ..., vn}",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 : entiers",
            "  x ∈ [10 .. 20]      → vrai si x est entre 10 et 20 (inclus)",
            "  x ∈ {2, 4, 6, 8}    → vrai si x est pair et ≤ 8",
            "",
            "Exemple 2 : caractères",
            "  c ∈ [\"A\" .. \"Z\"]    → vrai si c est une lettre majuscule",
            "  c ∈ {\"A\", \"E\", \"I\", \"O\", \"U\", \"Y\"} → vrai si c est une voyelle",
            "",
            "Exemple 3 : booléens",
            "  b ∈ {vrai, faux}    → toujours vrai",
            "  b ∈ {faux}          → vrai seulement si b est faux"
        ]
    },
    "opérateur =": {
        "prefix": ["="],
        "body": "= $0",
        "description": [
            "opérateur = (égal)",
            "",
            "Syntaxe : expression1 = expression2",
            "Retourne vrai si expression1 est égale à expression2,",
            "faux sinon.",
            "",
            "S'applique uniquement aux types simples : ",
            "  - entier, réel, booléen, caractère et chaîne.",
            "Contrainte : Les deux expressions doivent être de types compatibles",
            "pour la comparaison.",
            "",
            "Types compatibles :",
            "  - entier, réel : comparaison numérique",
            "  - caractère, chaîne : comparaison ASCII/lexicographique",
            "  - booléen : comparaison des valeurs booléennes",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 : nombres",
            "  5 = 3     → faux",
            "  4 = 4.0   → vrai",
            "  2 = 2     → vrai",
            "",
            "Exemple 2 : caractères",
            "  \"A\" = \"a\" → faux  (65 ≠ 97 en ASCII)",
            "  \"B\" = \"B\" → vrai",
            "",
            "Exemple 3 : chaînes",
            "  \"Ali\" = \"Ahmed\" → faux",
            "  \"test\" = \"test\" → vrai",
            "",
            "Exemple 4 : booléens",
            "  vrai = faux → faux",
            "  vrai = vrai → vrai",
            "",
            "Note : Ne pas confondre avec l'opérateur d'affectation '<--'"
        ]
    },
    "opérateur ≠": {
        "prefix": ["!=", "<>"],
        "body": ["≠ $0"],
        "description": [
            "opérateur ≠ (différent)",
            "",
            "Syntaxe : expression1 ≠ expression2",
            "Retourne vrai si expression1 et expression2 ont des valeurs différentes,",
            "faux si elles sont égales.",
            "",
            "S'applique à tous les types simples :",
            "  - entier, réel, booléen, caractère et chaîne.",
            "Contrainte : Les deux expressions doivent être de types compatibles",
            "pour la comparaison.",
            "",
            "Types compatibles :",
            "  - entier, réel : comparaison numérique",
            "  - caractère, chaîne : comparaison lexicographique (basée sur ASCII)",
            "  - booléen : faux ≠ vrai",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 : nombres",
            "  5 ≠ 3     → vrai",
            "  4 ≠ 4.0   → faux",
            "  2 ≠ 2     → faux",
            "",
            "Exemple 2 : caractères",
            "  \"A\" ≠ \"a\" → vrai  (65 ≠ 97 en ASCII)",
            "  \"#\" ≠ \"#\" → faux",
            "",
            "Exemple 3 : chaînes",
            "  \"Ali\" ≠ \"Ahmed\" → vrai",
            "  \"Test\" ≠ \"Test\" → faux",
            "",
            "Exemple 4 : booléens",
            "  vrai ≠ faux → vrai",
            "  faux ≠ faux → faux"
        ]
    },
    "affectation (<--)": {
        "prefix": ["<--"],
        "body": ["<-- $0"],
        "description": [
            "opérateur d'affectation :",
            "stocke la valeur d'une expression dans une case mémoire.",
            "",
            "Syntaxe :",
            "  case_mémoire <-- expression",
            "",
            "La case mémoire doit être de type simple :",
            "  - entier, réel, booléen, caractère ou chaîne",
            "",
            "La case mémoire peut être :",
            "  - une variable simple (ex. : age),",
            "  - un élément de tableau (ex. : T[0], T[i]),",
            "  - un champ d'enregistrement (ex. : personne.nom).",
            "",
            "Contrainte :",
            "  l'expression doit être compatible avec le type de la case mémoire.",
            "",
            "~~~~~~~~~~~~~~",
            "Exemples :",
            "  x <-- 42",
            "  T[i] <-- x + 1",
            "  pers.nom <-- \"Ali\""
        ]
    },
    "opérateur et": {
        "prefix": "et",
        "body": ["et $0"],
        "description": [
            "opérateur et (and logique)",
            "",
            "Syntaxe : exp1 et exp2",
            "",
            "Retourne vrai si les deux expressions sont vraies, faux sinon.",
            "",
            "Contrainte :",
            "  - Les deux expressions doivent être de type booléen.",
            "",
            "Évaluation en court-circuit :",
            "  - Si exp1 est faux, exp2 n'est pas évaluée.",
            "",
            "Table de vérité :",
            "  vrai et vrai → vrai",
            "  vrai et faux → faux",
            "  faux et vrai → faux",
            "  faux et faux → faux",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 :",
            "  a <-- 5 > 0",
            "  b <-- 10 < 20",
            "  si a et b alors",
            "    écrire(\"Les deux conditions sont vraies\")",
            "  fin_si",
            "  → Affiche \"Les deux conditions sont vraies\" (car vrai et vrai → vrai)",
            "",
            "Exemple 2 :",
            "  x <-- 3",
            "  si x > 0 et x < 2 alors",
            "    écrire(\"x est entre 0 et 2\")",
            "  fin_si",
            "  → N'affiche rien (car vrai et faux → faux)"
        ]
    },
    "opérateur ou": {
        "prefix": "ou",
        "body": ["ou $0"],
        "description": [
            "opérateur ou (or logique)",
            "",
            "Syntaxe : exp1 ou exp2",
            "",
            "Retourne vrai si au moins l'une des expressions est vraie,",
            "faux si les deux sont fausses.",
            "",
            "Contrainte :",
            "  - Les deux expressions doivent être de type booléen.",
            "",
            "Évaluation en court-circuit :",
            "  - Si exp1 est vrai, exp2 n'est pas évaluée.",
            "",
            "Table de vérité :",
            "  vrai ou vrai → vrai",
            "  vrai ou faux → vrai",
            "  faux ou vrai → vrai",
            "  faux ou faux → faux",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 :",
            "  a <-- 5 > 0",
            "  b <-- 10 > 20",
            "  si a ou b alors",
            "    écrire(\"Au moins une condition est vraie\")",
            "  fin_si",
            "  → Affiche \"Au moins une condition est vraie\" (car vrai ou faux → vrai)",
            "",
            "Exemple 2 :",
            "  age <-- 16",
            "  si age < 6 ou age > 60 alors",
            "    écrire(\"Tarif réduit applicable\")",
            "  fin_si",
            "  → N'affiche rien (faux ou faux → faux)"
        ]
    },
    "opérateur non": {
        "prefix": "non",
        "body": ["non $0"],
        "description": [
            "opérateur non (not logique)",
            "",
            "Syntaxe : non exp",
            "",
            "Retourne l'inverse logique de l'expression :",
            "  - si exp est vrai, retourne faux",
            "  - si exp est faux, retourne vrai",
            "",
            "Contrainte :",
            "  - L'expression doit être de type booléen.",
            "",
            "Table de vérité :",
            "  non vrai → faux",
            "  non faux → vrai",
            "",
            "Exemple :",
            "  age <-- 16",
            "  si non (age ≥ 18) alors",
            "    écrire(\"Mineur - accès refusé\")",
            "  fin_si",
            "  → Affiche \"Mineur - accès refusé\" (car non faux → vrai)"
        ]
    },
    "opérateur div": {
        "prefix": "div",
        "body": ["div $0"],
        "description": [
            "opérateur div (division entière)",
            "",
            "Syntaxe : a div b",
            "",
            "Rôle : Retourne la partie entière du quotient (troncature vers zéro).",
            "",
            "Contraintes :",
            "  - a et b doivent être de type entier.",
            "  - b doit être non nul (≠ 0).",
            "",
            "Propriété fondamentale :",
            "  - a = (a div b) * b + (a mod b)",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 : Division positive",
            "  17 div 5  → 3",
            "  17 mod 5  → 2",
            "  Vérification : 17 = 3 * 5 + 2 ✓",
            "",
            "Exemple 2 : Quotient nul",
            "  7 div 10  → 0",
            "  7 mod 10  → 7",
            "  Vérification : 7 = 0 * 10 + 7 ✓",
            "",
            "Exemple 3 : Dividende négatif",
            "  -15 div 4 → -3",
            "  -15 mod 4 → -3",
            "  Vérification : -15 = (-3) * 4 + (-3) ✓",
            "",
            "Exemple 4 : Diviseur négatif",
            "  15 div -4 → -3",
            "  15 mod -4 → 3",
            "  Vérification : 15 = (-3) * (-4) + 3 ✓",
            "",
            "Exemple 5 : Les deux négatifs",
            "  -15 div -4 → 3",
            "  -15 mod -4 → -3",
            "  Vérification : -15 = 3 * (-4) + (-3) ✓",
            "",
            "Exemple 6 : Utilisation pratique (conversion de temps)",
            "  heures <-- temps_secondes div 3600",
            "  minutes <-- (temps_secondes mod 3600) div 60",
            "  secondes <-- temps_secondes mod 60"
        ]
    },
    "opérateur mod": {
        "prefix": "mod",
        "body": ["mod $0"],
        "description": [
            "opérateur mod (modulo / reste de la division entière)",
            "",
            "Syntaxe : a mod b",
            "",
            "Rôle : Retourne le reste de la division entière de a par b.",
            "",
            "Contraintes :",
            "  - a et b doivent être de type entier.",
            "  - Le diviseur (b) doit être non nul (≠ 0).",
            "",
            "Propriétés fondamentales :",
            "  - a = (a div b) * b + (a mod b)",
            "  - Le signe du reste est le même que celui du dividende (a).",
            "",
            "~~~~~~~~~~~~~~",
            "Exemple 1 : Division positive",
            "  17 mod 5  → 2",
            "  Vérification : 17 = (17 div 5) * 5 + 2 = 3*5 + 2 ✓",
            "",
            "Exemple 2 : Reste nul",
            "  20 mod 4  → 0",
            "  Vérification : 20 = 5*4 + 0 ✓",
            "",
            "Exemple 3 : Dividende négatif",
            "  -15 mod 4 → -3",
            "  Vérification : -15 = (-15 div 4)*4 + (-3) = (-3)*4 + (-3) ✓",
            "",
            "Exemple 4 : Diviseur négatif",
            "  15 mod -4 → 3",
            "  Vérification : 15 = (15 div -4)*(-4) + 3 = (-3)*(-4) + 3 ✓",
            "",
            "Exemple 5 : Les deux négatifs",
            "  -15 mod -4 → -3",
            "  Vérification : -15 = (-15 div -4)*(-4) + (-3) = 3*(-4) + (-3) ✓",
            "",
            "Exemple 6 : Utilisation pratique",
            "  // tester si un nombre est pair",
            "  si n mod 2 = 0 alors",
            "    écrire(\"Pair\")",
            "  fin_si"
        ]
    },
    "faux": {
        "prefix": "faux",
        "body": ["faux $0"]
    },
    "vrai": {
        "prefix": "vrai",
        "body": ["vrai $0"]
    }
}
